<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Expressions | Arquero API Reference | arquero</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Expressions | Arquero API Reference" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Query processing and transformation of array-backed data tables." />
<meta property="og:description" content="Query processing and transformation of array-backed data tables." />
<link rel="canonical" href="expressions.html" />
<meta property="og:url" content="https://idl.uw.edu/arquero/api/expressions.html" />
<meta property="og:site_name" content="arquero" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Expressions | Arquero API Reference" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Query processing and transformation of array-backed data tables.","headline":"Expressions | Arquero API Reference","url":"https://idl.uw.edu/arquero/api/expressions.html"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="../assets/css/style.css@v=e8003b487ac362f5679ed130cb3a6597b684f903.css">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/arquero/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="https://idl.uw.edu/arquero/">arquero</a></h1>
      

      <h1 id="arquero-api-reference-">Arquero API Reference <a href="https://idl.uw.edu/arquero"><img align="right" src="../assets/logo.svg" height="38" /></a></h1>

<table>
  <tbody>
    <tr>
      <td><a href="https://idl.uw.edu/arquero/api">Top-Level</a></td>
      <td><a href="https://idl.uw.edu/arquero/api/table">Table</a></td>
      <td><a href="https://idl.uw.edu/arquero/api/verbs">Verbs</a></td>
      <td><a href="https://idl.uw.edu/arquero/api/op">Op Functions</a></td>
      <td><a href="https://idl.uw.edu/arquero/api/expressions"><strong>Expressions</strong></a></td>
      <td><a href="https://idl.uw.edu/arquero/api/extensibility">Extensibility</a></td>
    </tr>
  </tbody>
</table>

<ul>
  <li><a href="expressions.html#table">Table Expressions</a>
    <ul>
      <li><a href="expressions.html#limitations">Limitations</a></li>
      <li><a href="expressions.html#column-shorthands">Column Shorthands</a></li>
      <li><a href="expressions.html#aggregate-window-shorthands">Aggregate &amp; Window Shorthands</a></li>
    </ul>
  </li>
  <li><a href="expressions.html#two-table">Two-Table Expressions</a>
    <ul>
      <li><a href="expressions.html#two-table-column-shorthands">Column Shorthands</a></li>
    </ul>
  </li>
  <li><a href="expressions.html#why-op-functions-only">Why are only <code class="language-plaintext highlighter-rouge">op</code> functions supported?</a></li>
</ul>

<p><br /></p>

<h2 id="table-expressions"><a id="table">Table Expressions</a></h2>

<p>Most Arquero <a href="https://idl.uw.edu/arquero/api/verbs">verbs</a> accept <em>table expressions</em>: functions defined over table column values. For example, the <code class="language-plaintext highlighter-rouge">derive</code> verb creates new columns based on the provided expressions:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">table</span><span class="p">.</span><span class="nx">derive</span><span class="p">({</span>
  <span class="na">raise</span><span class="p">:</span> <span class="nx">d</span> <span class="o">=&gt;</span> <span class="nx">op</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">col1</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">col2</span><span class="p">),</span>
  <span class="dl">'</span><span class="s1">col diff</span><span class="dl">'</span><span class="p">:</span> <span class="nx">d</span> <span class="o">=&gt;</span> <span class="nx">d</span><span class="p">.</span><span class="nx">col1</span> <span class="o">-</span> <span class="nx">d</span><span class="p">[</span><span class="dl">'</span><span class="s1">base col</span><span class="dl">'</span><span class="p">]</span>
<span class="p">})</span>
</code></pre></div></div>

<p>In the example above, the two <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">arrow function expressions</a> are table expressions. The input argument <code class="language-plaintext highlighter-rouge">d</code> represents a row of the data table, whose properties are column names. Table expressions can include standard JavaScript expressions and invoke functions defined on the <a href="https://idl.uw.edu/arquero/api/op"><code class="language-plaintext highlighter-rouge">op</code> object</a>, which, depending on the context, may include <a href="https://idl.uw.edu/arquero/api/op#functions">standard</a>, <a href="https://idl.uw.edu/arquero/api/op#aggregate-functions">aggregate</a>, or <a href="https://idl.uw.edu/arquero/api/op#window-functions">window</a> functions.</p>

<p>At first glance table expressions look like normal JavaScript functions… but hold on! Under the hood, Arquero takes a set of function definitions, maps them to strings, then parses, rewrites, and compiles them to efficiently manage data internally. From Arquero’s point of view, the following examples are all equivalent:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">function(d) { return op.sqrt(d.value); }</code></li>
  <li><code class="language-plaintext highlighter-rouge">d =&gt; op.sqrt(d.value)</code></li>
  <li><code class="language-plaintext highlighter-rouge">({ value }) =&gt; op.sqrt(value)</code></li>
  <li><code class="language-plaintext highlighter-rouge">d =&gt; sqrt(d.value)</code></li>
  <li><code class="language-plaintext highlighter-rouge">d =&gt; aq.op.sqrt(d.value)</code></li>
  <li><code class="language-plaintext highlighter-rouge">"d =&gt; op.sqrt(d.value)"</code></li>
  <li><code class="language-plaintext highlighter-rouge">"sqrt(d.value)"</code></li>
</ol>

<p>Examples 1 through 5 are function definitions, while examples 6 and 7 are string literals. Let’s walk through each:</p>

<ul>
  <li><em>Examples 1-3</em>: These are just different variants of writing standard JavaScript functions: traditional function definitions, arrow function definitions, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">destructured arguments</a>.</li>
  <li><em>Examples 4-5</em>: While it is conventional to use the <a href="https://idl.uw.edu/arquero/api/op"><code class="language-plaintext highlighter-rouge">op</code> object</a> to invoke functions, it is not required. For <em>any</em> function invocation, the function name will be looked up on the <code class="language-plaintext highlighter-rouge">op</code> object, even if the function is called directly (as in Example 4) or as the result of a nested property lookup (Example 5). Internally, Arquero’s parser doesn’t care if you call <code class="language-plaintext highlighter-rouge">sqrt()</code>, <code class="language-plaintext highlighter-rouge">op.sqrt()</code>, or <code class="language-plaintext highlighter-rouge">aq.op.sqrt()</code>; any will work. That said, using an explicit <code class="language-plaintext highlighter-rouge">op</code> object avoids errors and allows linting and auto-complete to proceed unimpeded.</li>
  <li><em>Examples 6-7</em>: To parse table expressions, Arquero first maps input functions to source code strings. We can simply skip this step and pass a string directly, as in Example 6. For Example 7, the string contains an expression but not a function definition. In this case, an implicit function definition is assumed and the row identifier defaults to <code class="language-plaintext highlighter-rouge">d</code>; using an identifier other than <code class="language-plaintext highlighter-rouge">d</code> will fail. In contrast, with an explicit function definition you are free to rename the argument as you see fit.</li>
</ul>

<h3 id="limitations"><a id="limitations">Limitations</a></h3>

<p>A number of JavaScript features are not allowed in table expressions, including internal function definitions, variable updates, and <code class="language-plaintext highlighter-rouge">for</code> loops. The <em>only</em> function calls allowed are those provided by the <code class="language-plaintext highlighter-rouge">op</code> object. (<a href="expressions.html#why-op-functions-only">Why? Read below for more…</a>) Most notably, parsed table expressions <strong>do not support closures</strong>. As a result, table expressions can not access variables defined in the enclosing scope.</p>

<p>To include external variables in a table expression, use the <a href="https://idl.uw.edu/arquero/api/table#params"><code class="language-plaintext highlighter-rouge">params()</code> method</a> method to bind a parameter value to a table context. Parameters can then be accessed by including a second argument to a table expression; all bound parameters are available as properties of that argument (default name <code class="language-plaintext highlighter-rouge">$</code>):</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">table</span>
  <span class="p">.</span><span class="nx">params</span><span class="p">({</span> <span class="na">threshold</span><span class="p">:</span> <span class="mi">5</span> <span class="p">})</span>
  <span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">d</span><span class="p">,</span> <span class="nx">$</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">d</span><span class="p">.</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="nx">$</span><span class="p">.</span><span class="nx">threshold</span><span class="p">)</span>
</code></pre></div></div>

<p>To pass in a standard JavaScript function that will be called directly (rather than parsed and rewritten), use the <a href="https://idl.uw.edu/arquero/api/#escape"><code class="language-plaintext highlighter-rouge">escape()</code> expression helper</a>. Escaped functions <em>do</em> support closures and so can refer to variables defined in an enclosing scope. However, escaped functions do not support aggregate or window operations; they also sidestep internal optimizations and result in an error when attempting to serialize Arquero queries (for example, to pass transformations to a worker thread).</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">threshold</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nx">table</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">aq</span><span class="p">.</span><span class="nx">escape</span><span class="p">(</span><span class="nx">d</span> <span class="o">=&gt;</span> <span class="nx">d</span><span class="p">.</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="nx">threshold</span><span class="p">))</span>
</code></pre></div></div>

<p>Alternatively, for programmatic generation of table expressions one can fallback to a generating a string – rather than a proper function definition – and use that instead:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// note: threshold must safely coerce to a string!</span>
<span class="kd">const</span> <span class="nx">threshold</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nx">table</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="s2">`d =&gt; d.value &lt; </span><span class="p">${</span><span class="nx">threshold</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="column-shorthands"><a id="column-shorthands">Column Shorthands</a></h3>

<p>Some verbs – including <a href="https://idl.uw.edu/arquero/api/verbs#groupby"><code class="language-plaintext highlighter-rouge">groupby()</code></a>, <a href="https://idl.uw.edu/arquero/api/verbs#orderby"><code class="language-plaintext highlighter-rouge">orderby()</code></a>, <a href="https://idl.uw.edu/arquero/api/verbs#fold"><code class="language-plaintext highlighter-rouge">fold()</code></a>, <a href="https://idl.uw.edu/arquero/api/verbs#pivot"><code class="language-plaintext highlighter-rouge">pivot()</code></a>, and <a href="https://idl.uw.edu/arquero/api/verbs#join"><code class="language-plaintext highlighter-rouge">join()</code></a> – accept shorthands such as column name strings. Given a table with columns <code class="language-plaintext highlighter-rouge">colA</code> and <code class="language-plaintext highlighter-rouge">colB</code> (in that order), the following are equivalent:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">table.groupby('colA', 'colB')</code> - Refer to columns by name</li>
  <li><code class="language-plaintext highlighter-rouge">table.groupby(['colA', 'colB'])</code> - Use an explicit array of names</li>
  <li><code class="language-plaintext highlighter-rouge">table.groupby(0, 1)</code> - Refer to columns by index</li>
  <li><code class="language-plaintext highlighter-rouge">table.groupby(aq.range(0, 1))</code> - Use a column <a href="index.html#range">range</a> helper</li>
  <li><code class="language-plaintext highlighter-rouge">table.groupby({ colA: d =&gt; d.colA, colB: d =&gt; d.colB })</code> - Explicit table expressions</li>
</ol>

<p>Underneath the hood, all of these variants are grounded down to table expressions.</p>

<h3 id="aggregate--window-shorthands"><a id="aggregate-window-shorthands">Aggregate &amp; Window Shorthands</a></h3>

<p>For <a href="https://idl.uw.edu/arquero/api/op#aggregate-functions">aggregate</a> and <a href="https://idl.uw.edu/arquero/api/op#window-functions">window</a> functions, use of the <code class="language-plaintext highlighter-rouge">op</code> object outside of a table expression allows the use of shorthand references. The following examples are equivalent:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">d =&gt; op.mean(d.value)</code> - Standard table expression</li>
  <li><code class="language-plaintext highlighter-rouge">op.mean('value')</code> - Shorthand table expression generator</li>
</ol>

<p>The second example produces an object that, when coerced to a string, generates <code class="language-plaintext highlighter-rouge">'d =&gt; op.mean(d["value"])'</code> as a result.</p>

<p><br /></p>

<h2 id="two-table-expressions"><a id="two-table">Two-Table Expressions</a></h2>

<p>For <a href="https://idl.uw.edu/arquero/api/verbs#joins">join</a> verbs, Arquero also supports <em>two-table</em> table expressions. Two-table expressions have an expanded signature that accepts two rows as input, one from the “left” table and one from the “right” table.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">table</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="nx">otherTable</span><span class="p">,</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">op</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">key</span><span class="p">))</span>
</code></pre></div></div>

<p>The use of aggregate and window functions is not allowed within two-table expressions. Otherwise, two-table expressions have the same capabilities and limitations as normal (single-table) table expressions.</p>

<p>Bound parameters can be accessed by including a third argument:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">table</span>
  <span class="p">.</span><span class="nx">params</span><span class="p">({</span> <span class="na">threshold</span><span class="p">:</span> <span class="mf">1.5</span> <span class="p">})</span>
  <span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="nx">otherTable</span><span class="p">,</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">$</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">op</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">value</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nx">$</span><span class="p">.</span><span class="nx">threshold</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="two-table-column-shorthands"><a id="two-table-column-shorthands">Two-Table Column Shorthands</a></h3>

<p>Rather than writing explicit two-table expressions, join verbs can also accept column shorthands in the form of a two-element array: the first element of the array is either a string or string array with columns in the first (left) table, whereas the second element indicates columns in the second (right) table.</p>

<p>Given two tables – one with columns <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and the other with columns <code class="language-plaintext highlighter-rouge">u</code>, <code class="language-plaintext highlighter-rouge">v</code> – the following examples are equivalent:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">table.join(other, ['x', 'u'], [['x', 'y'], 'v'])</code></li>
  <li><code class="language-plaintext highlighter-rouge">table.join(other, [['x'], ['u']], [['x', 'y'], ['v']])</code></li>
  <li><code class="language-plaintext highlighter-rouge">table.join(other, ['x', 'u'], [aq.all(), aq.not('u')])</code></li>
</ol>

<p>All of which are in turn equivalent to using the following two-table expressions:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">table</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="nx">other</span><span class="p">,</span> <span class="p">[</span><span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">u</span><span class="dl">'</span><span class="p">],</span> <span class="p">{</span>
  <span class="na">x</span><span class="p">:</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span>
  <span class="na">y</span><span class="p">:</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span>
  <span class="na">v</span><span class="p">:</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">v</span>
<span class="p">})</span>
</code></pre></div></div>

<h2 id="why-are-only-op-functions-supported"><a id="why-op-functions-only"></a>Why are only <code class="language-plaintext highlighter-rouge">op</code> functions supported?</h2>

<p>Any function that is callable within an Arquero table expression must be defined on the <code class="language-plaintext highlighter-rouge">op</code> object, either as a built-in function or added via the <a href="https://idl.uw.edu/arquero/api/extensibility">extensibility API</a>. Why is this the case?</p>

<p>As <a href="expressions.html#table">described earlier</a>, Arquero table expressions can look like normal JavaScript functions, but are treated specially: their source code is parsed and new custom functions are generated to process data. This process prevents the use of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">closures</a>, such as referencing functions or values defined externally to the expression.</p>

<p>So why do we do this? Here are a few reasons:</p>

<ul>
  <li>
    <p><strong>Performance</strong>. After parsing an expression, Arquero performs code generation, often creating more performant code in the process. This level of indirection also allows us to generate optimized expressions for certain inputs, such as Apache Arrow data.</p>
  </li>
  <li>
    <p><strong>Flexibility</strong>. Providing our own parsing also allows us to introduce new kinds of backing data without changing the API. For example, we could add support for different underlying data formats and storage layouts. More importantly, it also allows us analyze expressions and incorporate aggregate and window functions in otherwise “normal” JavaScript expressions.</p>
  </li>
  <li>
    <p><strong>Discoverability</strong>. Defining all functions on a single object provides a single catalog of all available operations. In most IDEs, you can simply type <code class="language-plaintext highlighter-rouge">op.</code> (and perhaps hit the <kbd>tab</kbd> key) to the see a list of all available functions and benefit from auto-complete!</p>
  </li>
</ul>

<p>Of course, one might wish to make different trade-offs. Arquero is designed to support common use cases while also being applicable to more complex production setups. This goal comes with the cost of more rigid management of functions. However, Arquero can be extended with custom variables, functions, and even new table methods or verbs! As starting points, see the <a href="https://idl.uw.edu/arquero/api/table#params">params</a> and <a href="https://idl.uw.edu/arquero/api/extensibility#addFunction">addFunction</a> methods to introduce external variables or register new <code class="language-plaintext highlighter-rouge">op</code> functions.</p>

<p>All that being said, Arquero provides an escape hatch: use the <a href="https://idl.uw.edu/arquero/api/#escape"><code class="language-plaintext highlighter-rouge">escape()</code> expression helper</a> to apply a standard JavaScript function <em>as-is</em>, skipping any internal parsing and code generation. As a result, escaped functions do <em>not</em> support aggregation and window operations, as these depend on Arquero’s internal parsing and code generation.</p>


      
      <div class="footer border-top border-gray-light mt-5 pt-3 text-right text-gray">
        This site is open source. <a href="https://github.com/uwdata/arquero/edit/main/docs/api/expressions.md">Improve this page</a>.
      </div>
      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
  </body>
</html>
