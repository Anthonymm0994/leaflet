<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Test</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, sans-serif; background: #0a0a0a; color: #e0e0e0; overflow: hidden; }
        #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        .progress { width: 400px; height: 6px; background: #333; margin-top: 10px; border-radius: 3px; }
        .progress-bar { height: 100%; background: #4a9eff; transition: width 0.1s; border-radius: 3px; }
        #main { display: none; height: 100vh; padding: 8px; }
        .header { background: #1a1a1a; padding: 8px 16px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .stats { display: flex; gap: 15px; font-size: 13px; }
        .stats span { display: flex; align-items: center; gap: 5px; }
        .stats strong { color: #4a9eff; }
        button { background: #4a9eff; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px; transition: all 0.2s; }
        button:hover { background: #3a8eef; }
        button:active { transform: scale(0.95); }
        .grid { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap: 8px; height: calc(100% - 140px); }
        .panel { background: #1a1a1a; border-radius: 4px; padding: 8px; position: relative; }
        .panel-title { font-size: 13px; margin-bottom: 4px; font-weight: 500; }
        canvas { position: absolute; top: 28px; left: 8px; right: 8px; bottom: 20px; cursor: crosshair; }
        select { background: #333; color: #e0e0e0; border: 1px solid #555; padding: 3px 6px; border-radius: 3px; position: absolute; top: 4px; right: 8px; font-size: 11px; }
        #tooltip { position: fixed; background: rgba(0,0,0,0.95); padding: 6px 10px; border-radius: 3px; font-size: 11px; pointer-events: none; display: none; z-index: 1000; border: 1px solid #333; }
        .mini-mode { display: none; }
        .mini-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; }
        .mini-panel { background: #1a1a1a; border-radius: 4px; padding: 12px; text-align: center; }
        .mini-value { font-size: 24px; font-weight: 600; color: #4a9eff; }
        .mini-label { font-size: 11px; color: #999; margin-top: 4px; }
        #statsPanel { position: absolute; top: 60px; right: 16px; background: rgba(26,26,26,0.95); border: 1px solid #333; border-radius: 4px; padding: 12px; font-size: 12px; display: none; z-index: 100; }
        #statsPanel div { margin-bottom: 4px; }
        #statsPanel strong { color: #4a9eff; margin-left: 4px; }
        .range-display { 
            background: #1a1a1a; 
            padding: 12px 16px; 
            border-radius: 4px; 
            margin-bottom: 8px;
            display: flex; 
            gap: 24px; 
            flex-wrap: wrap;
        }
        .mini-mode .range-display {
            display: none;
        }
        .range-item { 
            display: flex; 
            flex-direction: column; 
            min-width: 120px;
        }
        .range-label { 
            font-size: 11px; 
            color: #888; 
            margin-bottom: 2px; 
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .range-value { 
            font-size: 13px; 
            color: #4a9eff; 
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div>Generating <strong>10</strong> rows...</div>
        <div class="progress"><div class="progress-bar" id="progress"></div></div>
        <div id="loadingStatus" style="margin-top: 8px; font-size: 12px; color: #999;"></div>
    </div>
    
    <div id="main">
        <div class="header">
            <h3>Debug Test</h3>
            <div class="stats">
                <span>Total: <strong>10</strong></span>
                <span>Filtered: <strong id="filteredCount">10</strong></span>
                <span>Selected: <strong id="percentFiltered">100%</strong></span>
                <span>cat_2=true: <strong id="cat2True">50%</strong></span>
            </div>
            <div style="display: flex; gap: 8px;">
                <button onclick="toggleStats()">ðŸ“Š Stats</button>
                <button id="miniModeBtn" onclick="toggleMiniMode()">ðŸ“± Mini</button>
                <button onclick="resetAll()">ðŸ”„ Reset</button>
                <button onclick="exportCSV()">ðŸ’¾ CSV</button>
                <button onclick="saveSnapshot()">ðŸ“· Snapshot</button>
            </div>
        </div>
        
        <div class="range-display">
            <div class="range-item">
                <span class="range-label">Time:</span>
                <span class="range-value" id="timeRange">00:00 - 23:59</span>
            </div>
            <div class="range-item">
                <span class="range-label">Strength:</span>
                <span class="range-value" id="strengthRange">0.00 - 100.00</span>
            </div>
            <div class="range-item">
                <span class="range-label">Width:</span>
                <span class="range-value" id="widthRange">0.00 - 200.00</span>
            </div>
            <div class="range-item">
                <span class="range-label">Height:</span>
                <span class="range-value" id="heightRange">0.00 - 10.00</span>
            </div>
            <div class="range-item">
                <span class="range-label">Angle:</span>
                <span class="range-value" id="angleRange">0Â° - 360Â°</span>
            </div>
        </div>
        
        <div class="grid" id="normalMode">
            <!-- Row 1: Original top row -->
            <div class="panel">
                <div class="panel-title">Time Distribution (24h)</div>
                <canvas id="timeCanvas"></canvas>
            </div>
            <div class="panel">
                <div class="panel-title">Strength Distribution</div>
                <canvas id="strengthCanvas"></canvas>
            </div>
            <div class="panel">
                <div class="panel-title">Angle Distribution</div>
                <canvas id="angleCanvas"></canvas>
            </div>
            
            <!-- Row 2: Original bottom row -->
            <div class="panel">
                <div class="panel-title">Width Distribution</div>
                <canvas id="widthCanvas"></canvas>
            </div>
            <div class="panel">
                <div class="panel-title">Height Distribution</div>
                <canvas id="heightCanvas"></canvas>
            </div>
            <div class="panel">
                <div class="panel-title">Category 4 Distribution</div>
                <canvas id="categoryCanvas"></canvas>
            </div>
            
            <!-- Row 3: NEW bottom row -->
            <div class="panel">
                <div class="panel-title">Score Distribution</div>
                <canvas id="scoreCanvas"></canvas>
            </div>
            <div class="panel">
                <div class="panel-title">Department (8 categories)</div>
                <canvas id="departmentCanvas"></canvas>
            </div>
            <div class="panel">
                <div class="panel-title">Active Status (2 categories)</div>
                <canvas id="statusCanvas"></canvas>
            </div>
        </div>
        
        <div class="mini-mode">
            <div class="mini-grid">
                <div class="mini-panel">
                    <div class="mini-value" id="miniFiltered">10M</div>
                    <div class="mini-label">Filtered</div>
                </div>
                <div class="mini-panel">
                    <div class="mini-value" id="miniPercent">100%</div>
                    <div class="mini-label">of Total</div>
                </div>
                <div class="mini-panel">
                    <div class="mini-value" id="miniAvgStrength">50</div>
                    <div class="mini-label">Avg Strength</div>
                </div>
                <div class="mini-panel">
                    <div class="mini-value" id="miniAvgWidth">50</div>
                    <div class="mini-label">Avg Width</div>
                </div>
                <div class="mini-panel">
                    <div class="mini-value" id="miniAvgHeight">5</div>
                    <div class="mini-label">Avg Height</div>
                </div>
                <div class="mini-panel">
                    <div class="mini-value" id="miniCat2">50%</div>
                    <div class="mini-label">Cat2 True</div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="tooltip"></div>
    <div id="statsPanel"></div>
    
    <script>
        // ============================================================================
        // EXTENDED DATA EXPLORER - 3x3 GRID WITH ORIGINAL + NEW CHARTS
        // ============================================================================
        
        const ROWS = 1000;
        const BATCH_SIZE = 100000;
        
        let data = {
            width: null,
            height: null,
            angle: null,
            strength: null,
            timeSeconds: null,
            category_4: null,
            category_2: null,
            score: null,         // NEW: for histogram
            department: null,    // NEW: 8 categories
            status: null         // NEW: 2 categories
        };
        
        let filteredIndices = new Uint8Array(ROWS);
        let currentRows = ROWS;
        let binCache = {};
        let charts = {};
        let filters = {
            width: null,
            height: null,
            strength: null,
            time: null,
            angle: null,
            category: new Set(),
            categoryType: 'cat4',
            score: null,         // NEW
            department: new Set(), // NEW
            status: new Set()    // NEW
        };
        
        function normalRandom(mean, stddev) {
            const u1 = Math.random();
            const u2 = Math.random();
            const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            return mean + z0 * stddev;
        }
        
        async function generateData() {
            data.width = new Float32Array(ROWS);
            data.height = new Float32Array(ROWS);
            data.angle = new Float32Array(ROWS);
            data.strength = new Float32Array(ROWS);
            data.timeSeconds = new Float32Array(ROWS);
            data.category_4 = new Uint8Array(ROWS);
            data.category_2 = new Uint8Array(ROWS);
            data.score = new Float32Array(ROWS);        // NEW
            data.department = new Uint8Array(ROWS);     // NEW: 8 categories
            data.status = new Uint8Array(ROWS);         // NEW: 2 categories
            
            let i = 0;
            function batch() {
                const end = Math.min(i + BATCH_SIZE, ROWS);
                // Your CSV data embedded here
                const csvData = [
                {
                                "width": 45.2,
                                "height": 4.8,
                                "angle": 120.5,
                                "strength": 78.3,
                                "timeSeconds": 28800,
                                "category_4": 0,
                                "score": 85.2,
                                "department": 0,
                                "status": 1
                },
                {
                                "width": 52.1,
                                "height": 6.2,
                                "angle": 45.0,
                                "strength": 65.7,
                                "timeSeconds": 43200,
                                "category_4": 1,
                                "score": 92.1,
                                "department": 1,
                                "status": 1
                },
                {
                                "width": 38.9,
                                "height": 3.5,
                                "angle": 270.8,
                                "strength": 89.1,
                                "timeSeconds": 57600,
                                "category_4": 2,
                                "score": 78.5,
                                "department": 2,
                                "status": 0
                },
                {
                                "width": 61.3,
                                "height": 7.1,
                                "angle": 180.0,
                                "strength": 45.2,
                                "timeSeconds": 14400,
                                "category_4": 3,
                                "score": 88.9,
                                "department": 3,
                                "status": 1
                },
                {
                                "width": 29.7,
                                "height": 2.9,
                                "angle": 315.5,
                                "strength": 92.4,
                                "timeSeconds": 72000,
                                "category_4": 0,
                                "score": 76.3,
                                "department": 4,
                                "status": 1
                },
                {
                                "width": 48.5,
                                "height": 5.4,
                                "angle": 90.2,
                                "strength": 67.8,
                                "timeSeconds": 36000,
                                "category_4": 1,
                                "score": 94.7,
                                "department": 5,
                                "status": 0
                },
                {
                                "width": 55.8,
                                "height": 6.8,
                                "angle": 225.3,
                                "strength": 73.1,
                                "timeSeconds": 50400,
                                "category_4": 2,
                                "score": 81.2,
                                "department": 6,
                                "status": 1
                },
                {
                                "width": 42.3,
                                "height": 4.1,
                                "angle": 135.7,
                                "strength": 58.9,
                                "timeSeconds": 21600,
                                "category_4": 3,
                                "score": 87.6,
                                "department": 7,
                                "status": 1
                },
                {
                                "width": 67.2,
                                "height": 8.2,
                                "angle": 0.0,
                                "strength": 81.5,
                                "timeSeconds": 64800,
                                "category_4": 0,
                                "score": 79.8,
                                "department": 0,
                                "status": 0
                },
                {
                                "width": 33.1,
                                "height": 3.8,
                                "angle": 200.4,
                                "strength": 69.3,
                                "timeSeconds": 39600,
                                "category_4": 1,
                                "score": 91.4,
                                "department": 1,
                                "status": 1
                }
];
                
                for (; i < end; i++) {
                    if (i < csvData.length) {
                        const row = csvData[i];
                        data.width[i] = row.width || 50;
                        data.height[i] = row.height || 5;
                        data.angle[i] = row.angle || 0;
                        data.strength[i] = row.strength || 50;
                        data.timeSeconds[i] = row.timeSeconds || 43200;
                        data.category_4[i] = row.category_4 || 0;
                        data.category_2[i] = row.category_2 || 0;
                        data.score[i] = row.score || 75;
                        data.department[i] = row.department || 0;
                        data.status[i] = row.status || 1;
                    } else {
                        // Fill remaining with defaults if CSV is smaller than ROWS
                        data.width[i] = 50;
                        data.height[i] = 5;
                        data.angle[i] = Math.random() * 360;
                        data.strength[i] = 50;
                        data.timeSeconds[i] = 43200;
                        data.category_4[i] = 0;
                        data.category_2[i] = 0;
                        data.score[i] = 75;
                        data.department[i] = 0;
                        data.status[i] = 1;
                    }
                }
                
                const progress = (i / ROWS) * 100;
                document.getElementById('progress').style.width = progress + '%';
                document.getElementById('loadingStatus').textContent = `Generated ${i.toLocaleString()} rows...`;
                
                if (i < ROWS) {
                    setTimeout(batch, 1);
                } else {
                    filteredIndices.fill(1);
                    prebinData();
                    createCharts();
                    updateStats();
                    updateRanges();
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('main').style.display = 'block';
                }
            }
            batch();
        }
        
        function prebinData() {
            console.log('Starting prebinData...');
            binCache = {};
            
            // Pre-bin numerical data for histograms (with ULTRA-SAFE calculations)
            const fields = ['width', 'height', 'strength', 'score'];
            
            for (const field of fields) {
                console.log(`Processing field: ${field}`);
                const values = data[field];
                
                if (!values) {
                    console.warn(`Field ${field} is null or undefined`);
                    continue;
                }
                
                if (!Array.isArray(values) && !values.length) {
                    console.warn(`Field ${field} has no length property`);
                    continue;
                }
                
                if (values.length === 0) {
                    console.warn(`Field ${field} is empty`);
                    continue;
                }
                
                console.log(`Field ${field} has ${values.length} values`);
                
                // Ultra-safe min/max calculation
                let min = values[0];
                let max = values[0];
                let validCount = 0;
                
                for (let i = 0; i < values.length; i++) {
                    const val = values[i];
                    if (val !== null && val !== undefined && !isNaN(val)) {
                        if (val < min) min = val;
                        if (val > max) max = val;
                        validCount++;
                    }
                }
                
                if (validCount === 0) {
                    console.warn(`Field ${field} has no valid numeric values`);
                    continue;
                }
                
                console.log(`Field ${field}: min=${min}, max=${max}, validCount=${validCount}`);
                
                const numBins = 50; // Reduced from 100 for safety
                const range = max - min;
                const binSize = range > 0 ? range / numBins : 1;
                
                console.log(`Field ${field}: binSize=${binSize}`);
                
                // Create bins array with extra safety
                const bins = [];
                for (let b = 0; b < numBins; b++) {
                    bins[b] = [];
                }
                
                // Distribute values into bins
                for (let i = 0; i < values.length; i++) {
                    const val = values[i];
                    if (val !== null && val !== undefined && !isNaN(val)) {
                        let binIndex = Math.floor((val - min) / binSize);
                        binIndex = Math.max(0, Math.min(binIndex, numBins - 1));
                        
                        if (bins[binIndex] && Array.isArray(bins[binIndex])) {
                            bins[binIndex].push(i);
                        } else {
                            console.error(`Bin ${binIndex} is not an array for field ${field}`);
                        }
                    }
                }
                
                // Calculate max count safely
                let maxCount = 0;
                for (let i = 0; i < bins.length; i++) {
                    if (bins[i] && Array.isArray(bins[i]) && bins[i].length > maxCount) {
                        maxCount = bins[i].length;
                    }
                }
                
                console.log(`Field ${field}: maxCount=${maxCount}`);
                
                binCache[field] = {
                    bins,
                    min,
                    max,
                    binSize,
                    numBins,
                    maxCount
                };
            }
            
            // Pre-bin time data (24 hour bins) - ULTRA SAFE
            console.log('Processing time data...');
            const timeValues = data.timeSeconds;
            if (timeValues && timeValues.length > 0) {
                const timeBins = [];
                for (let h = 0; h < 24; h++) {
                    timeBins[h] = [];
                }
                
                for (let i = 0; i < timeValues.length; i++) {
                    const timeVal = timeValues[i];
                    if (timeVal !== null && timeVal !== undefined && !isNaN(timeVal)) {
                        let hour = Math.floor(timeVal / 3600);
                        hour = Math.max(0, Math.min(hour, 23));
                        
                        if (timeBins[hour] && Array.isArray(timeBins[hour])) {
                            timeBins[hour].push(i);
                        }
                    }
                }
                
                let timeMaxCount = 0;
                for (let i = 0; i < timeBins.length; i++) {
                    if (timeBins[i] && timeBins[i].length > timeMaxCount) {
                        timeMaxCount = timeBins[i].length;
                    }
                }
                
                binCache.time = {
                    bins: timeBins,
                    min: 0,
                    max: 86400,
                    binSize: 3600,
                    numBins: 24,
                    maxCount: timeMaxCount
                };
                
                console.log(`Time: maxCount=${timeMaxCount}`);
            }
            
            // Pre-bin angle data (36 bins = 10 degrees each) - ULTRA SAFE
            console.log('Processing angle data...');
            const angleValues = data.angle;
            if (angleValues && angleValues.length > 0) {
                const angleBins = [];
                for (let a = 0; a < 36; a++) {
                    angleBins[a] = [];
                }
                
                for (let i = 0; i < angleValues.length; i++) {
                    const angleVal = angleValues[i];
                    if (angleVal !== null && angleVal !== undefined && !isNaN(angleVal)) {
                        let binIndex = Math.floor(angleVal / 10);
                        binIndex = Math.max(0, Math.min(binIndex, 35));
                        
                        if (angleBins[binIndex] && Array.isArray(angleBins[binIndex])) {
                            angleBins[binIndex].push(i);
                        }
                    }
                }
                
                let angleMaxCount = 0;
                for (let i = 0; i < angleBins.length; i++) {
                    if (angleBins[i] && angleBins[i].length > angleMaxCount) {
                        angleMaxCount = angleBins[i].length;
                    }
                }
                
                binCache.angle = {
                    bins: angleBins,
                    min: 0,
                    max: 360,
                    binSize: 10,
                    numBins: 36,
                    maxCount: angleMaxCount
                };
                
                console.log(`Angle: maxCount=${angleMaxCount}`);
            }
            
            console.log('prebinData completed successfully');
        }
        
        // Base Chart class
        class Chart {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = 0;
                this.height = 0;
                this.resize();
                
                // Bind events
                this.canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                this.canvas.addEventListener('click', this.onClick.bind(this));
                window.addEventListener('resize', this.resize.bind(this));
            }
            
            resize() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = (rect.width - 16) * dpr;
                this.canvas.height = (rect.height - 36) * dpr;
                this.canvas.style.width = (rect.width - 16) + 'px';
                this.canvas.style.height = (rect.height - 36) + 'px';
                this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                this.width = rect.width - 16;
                this.height = rect.height - 36;
                this.draw();
            }
            
            clear() {
                this.ctx.fillStyle = '#1a1a1a';
                this.ctx.fillRect(0, 0, this.width, this.height);
            }
            
            getMousePos(e) {
                if (!e || !this.canvas) return { x: 0, y: 0 };
                const r = this.canvas.getBoundingClientRect();
                return {
                    x: (e.clientX - r.left) * (this.width / r.width),
                    y: (e.clientY - r.top) * (this.height / r.height)
                };
            }
            
            onMouseDown(e) {}
            onMouseMove(e) {}
            onMouseUp(e) {}
            onClick(e) {}
            draw() {}
            
            destroy() {
                window.removeEventListener('resize', this.resize);
                this.canvas.replaceWith(this.canvas.cloneNode(true));
            }
        }
        
        // Histogram Chart for numerical data
        class Histogram extends Chart {
            constructor(canvasId, binData, label, formatter) {
                super(canvasId);
                this.binData = binData;
                this.label = label;
                this.formatter = formatter;
                this.margin = { top: 10, right: 10, bottom: 40, left: 50 };
                this.isInteracting = false;
                this._raf = false;
            }
            
            getFilterKey() {
                return this.label.toLowerCase();
            }
            
            isInChartArea(p) {
                return p.x >= this.margin.left && p.x <= this.width - this.margin.right &&
                       p.y >= this.margin.top && p.y <= this.height - this.margin.bottom;
            }
            
            draw() {
                try {
                    this.clear();
                    
                    if (!this.binData || !this.binData.bins) {
                        console.warn(`No bin data for histogram ${this.label}`);
                        return;
                    }
                    
                    const width = this.width - this.margin.left - this.margin.right;
                    const height = this.height - this.margin.top - this.margin.bottom;
                    const bins = this.binData.bins;
                    
                    if (!bins || bins.length === 0) {
                        console.warn(`Empty bins for histogram ${this.label}`);
                        return;
                    }
                    
                    const barWidth = width / bins.length;
                    
                    const counts = new Float32Array(bins.length);
                    const filteredCounts = new Float32Array(bins.length);
                    
                    for (let i = 0; i < bins.length; i++) {
                        const bin = bins[i];
                        if (!bin || !Array.isArray(bin)) {
                            counts[i] = 0;
                            filteredCounts[i] = 0;
                            continue;
                        }
                        
                        counts[i] = bin.length;
                        
                        if (bin.length > 1000) {
                            let sampled = 0;
                            const step = Math.max(1, Math.floor(bin.length / 1000));
                            for (let j = 0; j < bin.length && sampled < 1000; j += step) {
                                if (filteredIndices[bin[j]]) sampled++;
                            }
                            filteredCounts[i] = (sampled / Math.min(1000, bin.length)) * bin.length;
                        } else {
                            filteredCounts[i] = bin.filter(idx => filteredIndices[idx]).length;
                        }
                    }
                    
                    const maxCount = this.binData.maxCount || 1;
                    
                    this.ctx.save();
                    this.ctx.translate(this.margin.left, this.margin.top);
                    
                    for (let i = 0; i < bins.length; i++) {
                        const x = i * barWidth;
                        const h = (counts[i] / maxCount) * height;
                        const fh = (filteredCounts[i] / maxCount) * height;
                        
                        this.ctx.fillStyle = '#2a2a2a';
                        this.ctx.fillRect(x, height - h, barWidth - 1, h);
                        this.ctx.fillStyle = '#4a9eff';
                        this.ctx.fillRect(x, height - fh, barWidth - 1, fh);
                    }
                    
                    if (this.selection) {
                        this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
                        this.ctx.strokeStyle = '#feca57';
                        this.ctx.lineWidth = 2;
                        const x1 = this.selection[0] * barWidth;
                        const x2 = (this.selection[1] + 1) * barWidth;
                        this.ctx.fillRect(x1, 0, x2 - x1, height);
                        this.ctx.strokeRect(x1, 0, x2 - x1, height);
                    }
                    
                    this.ctx.strokeStyle = '#444';
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, height);
                    this.ctx.lineTo(width, height);
                    this.ctx.moveTo(0, 0);
                    this.ctx.lineTo(0, height);
                    this.ctx.stroke();
                    
                    this.ctx.restore();
                } catch (error) {
                    console.error(`Error drawing histogram ${this.label}:`, error);
                }
            }
            
            onMouseDown(e) {
                if (!e) return;
                const p = this.getMousePos(e);
                if (!this.isInChartArea(p)) return;
                
                const x = p.x - this.margin.left;
                const width = this.width - this.margin.left - this.margin.right;
                const bin = Math.floor(x / (width / this.binData.bins.length));
                
                if (bin >= 0 && bin < this.binData.bins.length) {
                    this.isDragging = true;
                    this.isInteracting = true;
                    this.dragStart = bin;
                }
            }
            
            onMouseMove(e) {
                if (!this.isDragging || !e) return;
                
                const p = this.getMousePos(e);
                const x = p.x - this.margin.left;
                const width = this.width - this.margin.left - this.margin.right;
                
                if (x >= 0 && x <= width) {
                    const bin = Math.floor(x / (width / this.binData.bins.length));
                    if (bin >= 0 && bin < this.binData.bins.length) {
                        this.selection = [Math.min(this.dragStart, bin), Math.max(this.dragStart, bin)];
                        if (!this._raf) {
                            this._raf = true;
                            requestAnimationFrame(() => {
                                this._raf = false;
                                this.draw();
                            });
                        }
                    }
                }
            }
            
            onMouseUp() {
                if (this.isDragging && this.selection) {
                    const key = this.getFilterKey();
                    const min = this.binData.min + this.selection[0] * this.binData.binSize;
                    const max = this.binData.min + (this.selection[1] + 1) * this.binData.binSize;
                    filters[key] = [min, max];
                    applyFilters();
                }
                this.isDragging = false;
                setTimeout(() => { this.isInteracting = false; }, 100);
            }
            
            onClick(e) {
                if (!this.isInteracting) {
                    const p = this.getMousePos(e);
                    if (this.isInChartArea(p)) {
                        this.selection = null;
                        const key = this.getFilterKey();
                        if (filters[key]) {
                            filters[key] = null;
                            applyFilters();
                        }
                        this.draw();
                    }
                }
            }
        }
        
        // Angle Chart (radial)
        class AngleChart extends Chart {
            constructor(canvasId) {
                super(canvasId);
                this.isInteracting = false;
            }
            
            draw() {
                try {
                    this.clear();
                    
                    if (!binCache.angle || !binCache.angle.bins) {
                        console.warn('No angle bin data available');
                        return;
                    }
                    
                    const cx = this.width / 2;
                    const cy = this.height / 2;
                    const radius = Math.min(cx, cy) - 20;
                    const inner = radius * 0.3;
                    const bins = binCache.angle.bins;
                    const binSize = binCache.angle.binSize;
                    const maxCount = binCache.angle.maxCount;
                
                this.ctx.save();
                
                // Grid lines
                this.ctx.strokeStyle = '#2a2a2a';
                this.ctx.lineWidth = 0.5;
                for (let r = inner; r <= radius; r += (radius - inner) / 4) {
                    this.ctx.beginPath();
                    this.ctx.arc(cx, cy, r, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                for (let a = 0; a < 360; a += 30) {
                    const rad = (a - 90) * Math.PI / 180;
                    this.ctx.beginPath();
                    this.ctx.moveTo(cx + Math.cos(rad) * inner, cy + Math.sin(rad) * inner);
                    this.ctx.lineTo(cx + Math.cos(rad) * radius, cy + Math.sin(rad) * radius);
                    this.ctx.stroke();
                }
                
                // Data
                for (let i = 0; i < bins.length; i++) {
                    const bin = bins[i];
                    const count = bin.filter(idx => filteredIndices[idx]).length;
                    if (count < 1) continue;
                    
                    const start = (i * binSize - 90) * Math.PI / 180;
                    const end = ((i + 1) * binSize - 90) * Math.PI / 180;
                    const scale = (count / maxCount) * (radius - inner);
                    
                    this.ctx.fillStyle = '#4a9eff';
                    this.ctx.beginPath();
                    this.ctx.arc(cx, cy, inner, start, end);
                    this.ctx.arc(cx, cy, inner + scale, end, start, true);
                    this.ctx.closePath();
                    this.ctx.fill();
                }
                
                this.ctx.restore();
                } catch (error) {
                    console.error('Error drawing angle chart:', error);
                }
            }
            
            onMouseDown(e) {
                if (!e) return;
                const p = this.getMousePos(e);
                const cx = this.width / 2;
                const cy = this.height / 2;
                const dx = p.x - cx;
                const dy = p.y - cy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const radius = Math.min(cx, cy) - 20;
                
                if (dist >= radius * 0.3 && dist <= radius) {
                    const ang = Math.atan2(dy, dx) * 180 / Math.PI + 90;
                    this.isDragging = true;
                    this.dragStart = Math.floor(((ang + 360) % 360) / binCache.angle.binSize);
                }
            }
            
            onMouseMove(e) {
                if (!this.isDragging || !e) return;
                
                const p = this.getMousePos(e);
                const cx = this.width / 2;
                const cy = this.height / 2;
                const dx = p.x - cx;
                const dy = p.y - cy;
                const ang = Math.atan2(dy, dx) * 180 / Math.PI + 90;
                const bin = Math.floor(((ang + 360) % 360) / binCache.angle.binSize);
                
                let s = this.dragStart;
                let t = bin;
                if (Math.abs(t - s) > binCache.angle.numBins / 2) {
                    if (s < t) s += binCache.angle.numBins;
                    else t += binCache.angle.numBins;
                }
                this.selection = [Math.min(s, t) % binCache.angle.numBins, Math.max(s, t) % binCache.angle.numBins];
                this.draw();
            }
            
            onMouseUp() {
                if (this.isDragging && this.selection) {
                    filters.angle = [
                        this.selection[0] * binCache.angle.binSize,
                        (this.selection[1] + 1) * binCache.angle.binSize
                    ];
                    applyFilters();
                }
                this.isDragging = false;
            }
            
            onClick() {
                if (!this.isInteracting && this.selection) {
                    this.selection = null;
                    filters.angle = null;
                    applyFilters();
                    this.draw();
                }
            }
        }
        
        // Category Chart - SINGLE SELECTION ONLY
        class CategoryChart extends Chart {
            constructor(canvasId, categories, filterKey) {
                super(canvasId);
                this.categories = categories;
                this.filterKey = filterKey;
                this.margin = { top: 20, right: 10, bottom: 40, left: 60 };
                this.selectedCategory = null; // SINGLE selection only
            }
            
            draw() {
                this.clear();
                const width = this.width - this.margin.left - this.margin.right;
                const height = this.height - this.margin.top - this.margin.bottom;
                
                const counts = new Array(this.categories.length).fill(0);
                const totals = new Array(this.categories.length).fill(0);
                const step = Math.max(1, Math.floor(currentRows / 1000000));
                
                const dataField = this.filterKey === 'category' ? data.category_4 : 
                                 this.filterKey === 'department' ? data.department : data.status;
                
                for (let i = 0; i < currentRows; i += step) {
                    totals[dataField[i]]++;
                    if (filteredIndices[i]) {
                        counts[dataField[i]]++;
                    }
                }
                
                for (let i = 0; i < this.categories.length; i++) {
                    counts[i] *= step;
                    totals[i] *= step;
                }
                
                const maxCount = Math.max(...totals);
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#a8e6cf', '#dda0dd'];
                
                this.ctx.save();
                this.ctx.translate(this.margin.left, this.margin.top);
                
                const totalBar = width * 0.8;
                const gapW = width * 0.2;
                const barW = totalBar / this.categories.length;
                const gap = gapW / (this.categories.length + 1);
                
                for (let i = 0; i < this.categories.length; i++) {
                    const x = gap + i * (barW + gap);
                    const h = (totals[i] / maxCount) * height;
                    const fh = (counts[i] / maxCount) * height;
                    
                    this.ctx.fillStyle = '#2a2a2a';
                    this.ctx.fillRect(x, height - h, barW, h);
                    
                    const isSelected = this.selectedCategory === null || this.selectedCategory === i;
                    this.ctx.fillStyle = isSelected ? colors[i % colors.length] : '#444';
                    this.ctx.fillRect(x, height - fh, barW, fh);
                    
                    if (this.selectedCategory === i) {
                        this.ctx.strokeStyle = '#feca57';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(x - 1, height - h - 1, barW + 2, h + 2);
                    }
                    
                    this.ctx.fillStyle = '#888';
                    this.ctx.font = '12px -apple-system, sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(this.categories[i], x + barW / 2, height + 20);
                }
                
                this.ctx.restore();
            }
            
            onMouseDown(e) {
                if (!e) return;
                const p = this.getMousePos(e);
                const width = this.width - this.margin.left - this.margin.right;
                const height = this.height - this.margin.top - this.margin.bottom;
                const x = p.x - this.margin.left;
                const y = p.y - this.margin.top;
                
                if (x >= 0 && x <= width && y >= 0 && y <= height) {
                    const totalBar = width * 0.8;
                    const gapW = width * 0.2;
                    const barW = totalBar / this.categories.length;
                    const gap = gapW / (this.categories.length + 1);
                    
                    for (let i = 0; i < this.categories.length; i++) {
                        const bx = gap + i * (barW + gap);
                        if (x >= bx && x <= bx + barW) {
                            // SINGLE selection logic
                            if (this.selectedCategory === i) {
                                this.selectedCategory = null;
                                filters[this.filterKey].clear();
                            } else {
                                this.selectedCategory = i;
                                filters[this.filterKey].clear();
                                filters[this.filterKey].add(i);
                            }
                            
                            if (this.filterKey === 'category') {
                                filters.categoryType = 'cat4';
                            }
                            
                            applyFilters();
                            return;
                        }
                    }
                }
            }
        }
        
        function createCharts() {
            charts.time = new Histogram('timeCanvas', binCache.time, 'Time', (v) => {
                const hours = Math.floor(v / 3600);
                const minutes = Math.floor((v % 3600) / 60);
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            });
            
            charts.strength = new Histogram('strengthCanvas', binCache.strength, 'Strength', (v) => v.toFixed(2));
            charts.angle = new AngleChart('angleCanvas');
            charts.width = new Histogram('widthCanvas', binCache.width, 'Width', (v) => v.toFixed(2));
            charts.height = new Histogram('heightCanvas', binCache.height, 'Height', (v) => v.toFixed(2));
            charts.category = new CategoryChart('categoryCanvas', ['A', 'B', 'C', 'D'], 'category');
            
            // NEW CHARTS
            charts.score = new Histogram('scoreCanvas', binCache.score, 'Score', (v) => v.toFixed(1));
            charts.department = new CategoryChart('departmentCanvas', ['Engineering', 'Sales', 'Marketing', 'HR', 'Finance', 'Operations', 'Legal', 'Support'], 'department');
            charts.status = new CategoryChart('statusCanvas', ['Inactive', 'Active'], 'status');
            
            Object.values(charts).forEach(chart => chart.draw());
        }
        
        function applyFilters() {
            const newIndices = new Uint8Array(ROWS);
            newIndices.fill(1);
            
            // Apply range filters
            const rangeFilters = ['width', 'height', 'strength', 'time', 'angle', 'score'];
            for (const field of rangeFilters) {
                const filter = filters[field];
                if (filter && Array.isArray(filter) && filter.length === 2) {
                    const [min, max] = filter;
                    const dataField = field === 'time' ? data.timeSeconds : data[field];
                    
                    for (let i = 0; i < ROWS; i++) {
                        if (newIndices[i] && (dataField[i] < min || dataField[i] > max)) {
                            newIndices[i] = 0;
                        }
                    }
                }
            }
            
            // Apply category filters
            const categoryFilters = ['category', 'department', 'status'];
            for (const field of categoryFilters) {
                const filter = filters[field];
                if (filter && filter.size > 0) {
                    const dataField = field === 'category' ? data.category_4 : data[field];
                    
                    for (let i = 0; i < ROWS; i++) {
                        if (newIndices[i] && !filter.has(dataField[i])) {
                            newIndices[i] = 0;
                        }
                    }
                }
            }
            
            filteredIndices = newIndices;
            updateStats();
            updateRanges();
            Object.values(charts).forEach(chart => chart.draw());
        }
        
        function updateStats() {
            const totalCount = ROWS;
            const filteredCount = filteredIndices.reduce((sum, val) => sum + val, 0);
            const percent = totalCount > 0 ? ((filteredCount / totalCount) * 100).toFixed(1) : 0;
            
            document.getElementById('filteredCount').textContent = formatCount(filteredCount);
            document.getElementById('percentFiltered').textContent = percent + '%';
            
            // Update cat2 stats
            let cat2True = 0;
            let cat2Total = 0;
            for (let i = 0; i < ROWS; i++) {
                if (filteredIndices[i]) {
                    cat2Total++;
                    if (data.category_2[i] === 1) {
                        cat2True++;
                    }
                }
            }
            const cat2Percent = cat2Total > 0 ? ((cat2True / cat2Total) * 100).toFixed(1) : 0;
            document.getElementById('cat2True').textContent = cat2Percent + '%';
        }
        
        function updateRanges() {
            const fields = [
                { name: 'time', data: data.timeSeconds, format: formatTime },
                { name: 'strength', data: data.strength, format: formatNumber },
                { name: 'width', data: data.width, format: formatNumber },
                { name: 'height', data: data.height, format: formatNumber },
                { name: 'angle', data: data.angle, format: formatAngle }
            ];
            
            for (const field of fields) {
                const filteredData = field.data.filter((_, i) => filteredIndices[i]);
                if (filteredData.length > 0) {
                    let min = filteredData[0];
                    let max = filteredData[0];
                    for (let i = 1; i < filteredData.length; i++) {
                        if (filteredData[i] < min) min = filteredData[i];
                        if (filteredData[i] > max) max = filteredData[i];
                    }
                    const element = document.getElementById(field.name + 'Range');
                    if (element) {
                        element.textContent = `${field.format(min)} - ${field.format(max)}`;
                    }
                }
            }
        }
        
        function formatCount(count) {
            if (count >= 1000000) return (count / 1000000).toFixed(1) + 'M';
            if (count >= 1000) return (count / 1000).toFixed(1) + 'K';
            return count.toString();
        }
        
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
        }
        
        function formatNumber(num) {
            return num.toFixed(2);
        }
        
        function formatAngle(angle) {
            return angle.toFixed(1) + 'Â°';
        }
        
        function toggleStats() {
            const panel = document.getElementById('statsPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
        
        function toggleMiniMode() {
            const mainGrid = document.getElementById('normalMode');
            const miniMode = document.querySelector('.mini-mode');
            const rangeDisplay = document.querySelector('.range-display');
            
            if (mainGrid.style.display === 'none') {
                mainGrid.style.display = 'grid';
                miniMode.style.display = 'none';
                rangeDisplay.style.display = 'flex';
                document.getElementById('miniModeBtn').textContent = 'ðŸ“± Mini';
            } else {
                mainGrid.style.display = 'none';
                miniMode.style.display = 'block';
                rangeDisplay.style.display = 'none';
                document.getElementById('miniModeBtn').textContent = 'ðŸ“Š Full';
            }
        }
        
        function resetAll() {
            for (const key of Object.keys(filters)) {
                if (filters[key] instanceof Set) {
                    filters[key].clear();
                } else {
                    filters[key] = null;
                }
            }
            
            // Reset chart selections
            Object.values(charts).forEach(chart => {
                if (chart.selectedCategory !== undefined) {
                    chart.selectedCategory = null;
                }
                if (chart.selection) {
                    chart.selection = null;
                }
            });
            
            filteredIndices.fill(1);
            updateStats();
            updateRanges();
            Object.values(charts).forEach(chart => chart.draw());
        }
        
        function exportCSV() {
            const headers = ['width', 'height', 'angle', 'strength', 'timeSeconds', 'category_4', 'category_2', 'score', 'department', 'status'];
            const filteredData = [];
            
            for (let i = 0; i < ROWS; i++) {
                if (filteredIndices[i]) {
                    const row = headers.map(header => data[header][i]);
                    filteredData.push(row);
                }
            }
            
            const csvContent = [headers.join(','), ...filteredData.map(row => row.join(','))].join('\n');
            
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'filtered_data.csv';
            a.click();
            window.URL.revokeObjectURL(url);
        }
        
        function saveSnapshot() {
            const snapshot = {
                timestamp: new Date().toISOString(),
                filters: filters,
                filteredCount: filteredIndices.reduce((sum, val) => sum + val, 0),
                totalCount: ROWS
            };
            
            const dataStr = JSON.stringify(snapshot, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = window.URL.createObjectURL(dataBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'explorer_snapshot.json';
            a.click();
            window.URL.revokeObjectURL(url);
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            generateData();
        });
    </script>
</body>
</html>
