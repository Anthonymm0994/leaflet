<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Performance Data Explorer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, sans-serif; background: #0a0a0a; color: #e0e0e0; overflow: hidden; }
        #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        .progress { width: 400px; height: 6px; background: #333; margin-top: 10px; border-radius: 3px; }
        .progress-bar { height: 100%; background: #4a9eff; transition: width 0.1s; border-radius: 3px; }
        #main { display: none; height: 100vh; padding: 8px; }
        .header { background: #1a1a1a; padding: 8px 16px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .stats { display: flex; gap: 15px; font-size: 13px; }
        .stats span { display: flex; align-items: center; gap: 5px; }
        .stats strong { color: #4a9eff; }
        button { background: #4a9eff; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px; transition: all 0.2s; }
        button:hover { background: #3a8eef; }
        button:active { transform: scale(0.95); }
        .grid { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(2, 1fr); gap: 8px; height: calc(100% - 80px); }
        .panel { background: #1a1a1a; border-radius: 4px; padding: 8px; position: relative; }
        .panel-title { font-size: 13px; margin-bottom: 4px; font-weight: 500; }
        canvas { position: absolute; top: 28px; left: 8px; right: 8px; bottom: 8px; cursor: crosshair; }
        #tooltip { position: fixed; background: rgba(0,0,0,0.95); padding: 6px 10px; border-radius: 3px; font-size: 11px; pointer-events: none; display: none; z-index: 1000; border: 1px solid #333; }
    </style>
</head>
<body>
    <div id="loading">
        <div>Loading data...</div>
        <div class="progress"><div class="progress-bar" id="progress"></div></div>
        <div id="loadingStatus" style="margin-top: 8px; font-size: 12px; color: #999;"></div>
    </div>
    
    <div id="main">
        <div class="header">
            <h3 id="title">High-Performance Data Explorer</h3>
            <div class="stats">
                <span>Total: <strong id="totalCount">0</strong></span>
                <span>Filtered: <strong id="filteredCount">0</strong></span>
                <span>Selected: <strong id="percentFiltered">0%</strong></span>
            </div>
            <div style="display: flex; gap: 8px;">
                <button onclick="resetAll()">ðŸ”„ Reset</button>
                <button onclick="exportCSV()">ðŸ’¾ Export</button>
            </div>
        </div>
        
        <div class="grid" id="chartGrid">
            <!-- Charts will be dynamically created here -->
        </div>
    </div>
    
    <div id="tooltip"></div>
    
    <script>
        // ============================================================================
        // HIGH-PERFORMANCE DATA EXPLORER - FOCUSED VERSION
        // ============================================================================
        
        // Data configuration - easily embed your data here
        window.DataConfig = {
            title: "Sample Data Explorer",
            data: [], // Your data goes here
            columns: [], // Column definitions
            charts: [] // Chart configurations
        };
        
        // Global variables for performance
        let data = {};
        let filteredIndices = null;
        let totalRows = 0;
        let binCache = {};
        let charts = {};
        let filters = {};
        
        // ============================================================================
        // PERFORMANCE UTILITIES
        // ============================================================================
        
        function formatCount(count) {
            if (count >= 1000000) return (count / 1000000).toFixed(1) + 'M';
            if (count >= 1000) return (count / 1000).toFixed(1) + 'K';
            return count.toString();
        }
        
        function formatValue(value, type) {
            if (type === 'time') {
                const hours = Math.floor(value / 3600);
                const minutes = Math.floor((value % 3600) / 60);
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            }
            if (type === 'angle') {
                return value.toFixed(1) + 'Â°';
            }
            if (typeof value === 'number') {
                return value.toLocaleString();
            }
            return value.toString();
        }
        
        // ============================================================================
        // HIGH-PERFORMANCE DATA PROCESSING
        // ============================================================================
        
        class DataProcessor {
            static init(config) {
                DataConfig = config;
                document.getElementById('title').textContent = config.title || 'Data Explorer';
                
                totalRows = config.data.length;
                
                // Convert to TypedArrays for maximum performance
                data = {};
                for (const col of config.columns) {
                    const values = config.data.map(row => row[col.name]);
                    
                    switch (col.type) {
                        case 'integer':
                            data[col.name] = new Int32Array(values);
                            break;
                        case 'number':
                            data[col.name] = new Float32Array(values);
                            break;
                        case 'angle':
                            data[col.name] = new Float32Array(values);
                            break;
                        case 'time':
                            data[col.name] = new Float32Array(values);
                            break;
                        default:
                            data[col.name] = values; // Keep as array for strings
                    }
                }
                
                // Initialize filters
                filteredIndices = new Uint8Array(totalRows);
                filteredIndices.fill(1);
                
                filters = {};
                for (const col of config.columns) {
                    filters[col.name] = null;
                }
                
                // Pre-process data for charts
                this.prebinData();
                
                // Create UI
                this.createCharts();
                this.updateStats();
                
                // Show main interface
                document.getElementById('loading').style.display = 'none';
                document.getElementById('main').style.display = 'block';
            }
            
            static prebinData() {
                binCache = {};
                
                for (const col of DataConfig.columns) {
                    const values = data[col.name];
                    
                    if (col.type === 'number' || col.type === 'integer') {
                        // Histogram binning
                        const min = Math.min(...values);
                        const max = Math.max(...values);
                        const numBins = 50;
                        const binSize = (max - min) / numBins;
                        
                        const bins = Array(numBins).fill().map(() => []);
                        for (let i = 0; i < values.length; i++) {
                            const binIndex = Math.min(Math.floor((values[i] - min) / binSize), numBins - 1);
                            bins[binIndex].push(i);
                        }
                        
                        binCache[col.name] = {
                            type: 'histogram',
                            bins,
                            min,
                            max,
                            binSize,
                            numBins,
                            maxCount: Math.max(...bins.map(bin => bin.length))
                        };
                    }
                    else if (col.type === 'time') {
                        // Time binning (24 hours)
                        const min = Math.min(...values);
                        const max = Math.max(...values);
                        const numBins = 24;
                        const binSize = (max - min) / numBins;
                        
                        const bins = Array(numBins).fill().map(() => []);
                        for (let i = 0; i < values.length; i++) {
                            const binIndex = Math.min(Math.floor((values[i] - min) / binSize), numBins - 1);
                            bins[binIndex].push(i);
                        }
                        
                        binCache[col.name] = {
                            type: 'time',
                            bins,
                            min,
                            max,
                            binSize,
                            numBins,
                            maxCount: Math.max(...bins.map(bin => bin.length))
                        };
                    }
                    else if (col.type === 'angle') {
                        // Angle binning (36 bins = 10 degrees each)
                        const numBins = 36;
                        const binSize = 10;
                        
                        const bins = Array(numBins).fill().map(() => []);
                        for (let i = 0; i < values.length; i++) {
                            const binIndex = Math.floor(values[i] / binSize) % numBins;
                            bins[binIndex].push(i);
                        }
                        
                        binCache[col.name] = {
                            type: 'angle',
                            bins,
                            min: 0,
                            max: 360,
                            binSize,
                            numBins,
                            maxCount: Math.max(...bins.map(bin => bin.length))
                        };
                    }
                    else if (col.type === 'string') {
                        // Categorical binning
                        const uniqueValues = [...new Set(values)];
                        if (uniqueValues.length <= 20) {
                            const counts = {};
                            for (const val of uniqueValues) {
                                counts[val] = 0;
                            }
                            for (const val of values) {
                                counts[val]++;
                            }
                            
                            binCache[col.name] = {
                                type: 'categorical',
                                uniqueValues,
                                counts,
                                maxCount: Math.max(...Object.values(counts))
                            };
                        }
                    }
                }
            }
            
            static createCharts() {
                const grid = document.getElementById('chartGrid');
                grid.innerHTML = '';
                
                for (const chartConfig of DataConfig.charts) {
                    const panel = document.createElement('div');
                    panel.className = 'panel';
                    
                    const title = document.createElement('div');
                    title.className = 'panel-title';
                    title.textContent = chartConfig.title;
                    panel.appendChild(title);
                    
                    const canvas = document.createElement('canvas');
                    canvas.id = `chart_${chartConfig.column}`;
                    panel.appendChild(canvas);
                    
                    grid.appendChild(panel);
                    
                    // Create chart instance
                    const binData = binCache[chartConfig.column];
                    if (binData) {
                        if (binData.type === 'histogram' || binData.type === 'time') {
                            charts[chartConfig.column] = new HistogramChart(canvas.id, chartConfig.column);
                        } else if (binData.type === 'angle') {
                            charts[chartConfig.column] = new AngleChart(canvas.id, chartConfig.column);
                        } else if (binData.type === 'categorical') {
                            charts[chartConfig.column] = new BarChart(canvas.id, chartConfig.column);
                        }
                    }
                }
            }
            
            static updateStats() {
                const filteredCount = filteredIndices.reduce((sum, val) => sum + val, 0);
                const percent = totalRows > 0 ? ((filteredCount / totalRows) * 100).toFixed(1) : 0;
                
                document.getElementById('totalCount').textContent = formatCount(totalRows);
                document.getElementById('filteredCount').textContent = formatCount(filteredCount);
                document.getElementById('percentFiltered').textContent = percent + '%';
            }
        }
        
        // ============================================================================
        // FILTER SYSTEM
        // ============================================================================
        
        class FilterSystem {
            static applyFilters() {
                const newIndices = new Uint8Array(totalRows);
                newIndices.fill(1);
                
                // Apply all active filters
                for (const [column, filter] of Object.entries(filters)) {
                    if (!filter) continue;
                    
                    if (Array.isArray(filter)) {
                        // Range filter
                        const [min, max] = filter;
                        for (let i = 0; i < totalRows; i++) {
                            if (newIndices[i] && (data[column][i] < min || data[column][i] > max)) {
                                newIndices[i] = 0;
                            }
                        }
                    } else if (filter instanceof Set) {
                        // Categorical filter
                        for (let i = 0; i < totalRows; i++) {
                            if (newIndices[i] && !filter.has(data[column][i])) {
                                newIndices[i] = 0;
                            }
                        }
                    }
                }
                
                filteredIndices = newIndices;
                DataProcessor.updateStats();
                this.updateAllCharts();
            }
            
            static setFilter(column, filterValue) {
                filters[column] = filterValue;
                this.applyFilters();
            }
            
            static clearFilter(column) {
                filters[column] = null;
                this.applyFilters();
            }
            
            static clearAll() {
                for (const col of Object.keys(filters)) {
                    filters[col] = null;
                }
                filteredIndices.fill(1);
                DataProcessor.updateStats();
                this.updateAllCharts();
            }
            
            static updateAllCharts() {
                Object.values(charts).forEach(chart => chart.draw());
            }
        }
        
        // ============================================================================
        // HIGH-PERFORMANCE CHART CLASSES
        // ============================================================================
        
        class BaseChart {
            constructor(canvasId, column) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.column = column;
                this.width = 0;
                this.height = 0;
                
                this.setupCanvas();
                this.setupEvents();
                window.addEventListener('resize', this.resize.bind(this));
            }
            
            setupCanvas() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = (rect.width - 16) * dpr;
                this.canvas.height = (rect.height - 36) * dpr;
                this.canvas.style.width = (rect.width - 16) + 'px';
                this.canvas.style.height = (rect.height - 36) + 'px';
                this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                this.width = rect.width - 16;
                this.height = rect.height - 36;
                this.draw();
            }
            
            resize() {
                this.setupCanvas();
            }
            
            clear() {
                this.ctx.fillStyle = '#1a1a1a';
                this.ctx.fillRect(0, 0, this.width, this.height);
            }
            
            getMousePos(e) {
                const r = this.canvas.getBoundingClientRect();
                return {
                    x: (e.clientX - r.left) * (this.width / r.width),
                    y: (e.clientY - r.top) * (this.height / r.height)
                };
            }
            
            setupEvents() {
                this.canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                this.canvas.addEventListener('click', this.onClick.bind(this));
            }
            
            onMouseDown(e) {}
            onMouseMove(e) {}
            onMouseUp(e) {}
            onClick(e) {}
            draw() {}
        }
        
        // ============================================================================
        // HISTOGRAM CHART (for numerical and time data)
        // ============================================================================
        
        class HistogramChart extends BaseChart {
            constructor(canvasId, column) {
                super(canvasId, column);
                this.margin = { top: 10, right: 10, bottom: 30, left: 40 };
                this.isDragging = false;
                this.dragStart = 0;
                this.selection = null;
                this.isInteracting = false;
            }
            
            draw() {
                this.clear();
                const binData = binCache[this.column];
                if (!binData) return;
                
                const width = this.width - this.margin.left - this.margin.right;
                const height = this.height - this.margin.top - this.margin.bottom;
                const barWidth = width / binData.bins.length;
                
                // Calculate counts with performance optimization
                const counts = new Float32Array(binData.bins.length);
                const filteredCounts = new Float32Array(binData.bins.length);
                
                for (let i = 0; i < binData.bins.length; i++) {
                    const bin = binData.bins[i];
                    counts[i] = bin.length;
                    
                    // Performance optimization for large bins
                    if (bin.length > 1000) {
                        let sampled = 0;
                        const step = Math.max(1, Math.floor(bin.length / 1000));
                        for (let j = 0; j < bin.length && sampled < 1000; j += step) {
                            if (filteredIndices[bin[j]]) sampled++;
                        }
                        filteredCounts[i] = (sampled / Math.min(1000, bin.length)) * bin.length;
                    } else {
                        filteredCounts[i] = bin.filter(idx => filteredIndices[idx]).length;
                    }
                }
                
                const maxCount = binData.maxCount;
                
                this.ctx.save();
                this.ctx.translate(this.margin.left, this.margin.top);
                
                // Draw bars
                for (let i = 0; i < binData.bins.length; i++) {
                    const x = i * barWidth;
                    const h = (counts[i] / maxCount) * height;
                    const fh = (filteredCounts[i] / maxCount) * height;
                    
                    // Background bar
                    this.ctx.fillStyle = '#2a2a2a';
                    this.ctx.fillRect(x, height - h, barWidth - 1, h);
                    
                    // Filtered bar
                    this.ctx.fillStyle = '#4a9eff';
                    this.ctx.fillRect(x, height - fh, barWidth - 1, fh);
                }
                
                // Selection overlay
                if (this.selection) {
                    this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
                    this.ctx.strokeStyle = '#feca57';
                    this.ctx.lineWidth = 2;
                    const x1 = this.selection[0] * barWidth;
                    const x2 = (this.selection[1] + 1) * barWidth;
                    this.ctx.fillRect(x1, 0, x2 - x1, height);
                    this.ctx.strokeRect(x1, 0, x2 - x1, height);
                }
                
                // Axes
                this.ctx.strokeStyle = '#444';
                this.ctx.beginPath();
                this.ctx.moveTo(0, height);
                this.ctx.lineTo(width, height);
                this.ctx.moveTo(0, 0);
                this.ctx.lineTo(0, height);
                this.ctx.stroke();
                
                this.ctx.restore();
            }
            
            onMouseDown(e) {
                const p = this.getMousePos(e);
                const x = p.x - this.margin.left;
                const width = this.width - this.margin.left - this.margin.right;
                
                if (x >= 0 && x <= width && p.y >= this.margin.top && p.y <= this.height - this.margin.bottom) {
                    const binData = binCache[this.column];
                    const bin = Math.floor(x / (width / binData.bins.length));
                    
                    if (bin >= 0 && bin < binData.bins.length) {
                        this.isDragging = true;
                        this.isInteracting = true;
                        this.dragStart = bin;
                    }
                }
            }
            
            onMouseMove(e) {
                if (!this.isDragging) return;
                
                const p = this.getMousePos(e);
                const x = p.x - this.margin.left;
                const width = this.width - this.margin.left - this.margin.right;
                
                if (x >= 0 && x <= width) {
                    const binData = binCache[this.column];
                    const bin = Math.floor(x / (width / binData.bins.length));
                    if (bin >= 0 && bin < binData.bins.length) {
                        this.selection = [Math.min(this.dragStart, bin), Math.max(this.dragStart, bin)];
                        this.draw();
                    }
                }
            }
            
            onMouseUp() {
                if (this.isDragging && this.selection) {
                    const binData = binCache[this.column];
                    const min = binData.min + this.selection[0] * binData.binSize;
                    const max = binData.min + (this.selection[1] + 1) * binData.binSize;
                    
                    FilterSystem.setFilter(this.column, [min, max]);
                }
                
                this.isDragging = false;
                setTimeout(() => { this.isInteracting = false; }, 100);
            }
            
            onClick(e) {
                if (!this.isInteracting) {
                    this.selection = null;
                    FilterSystem.clearFilter(this.column);
                    this.draw();
                }
            }
        }
        
        // ============================================================================
        // ANGLE CHART (radial chart for angular data)
        // ============================================================================
        
        class AngleChart extends BaseChart {
            constructor(canvasId, column) {
                super(canvasId, column);
                this.isDragging = false;
                this.selection = null;
                this.isInteracting = false;
            }
            
            draw() {
                this.clear();
                const binData = binCache[this.column];
                if (!binData) return;
                
                const cx = this.width / 2;
                const cy = this.height / 2;
                const radius = Math.min(cx, cy) - 20;
                const inner = radius * 0.3;
                
                this.ctx.save();
                
                // Grid
                this.ctx.strokeStyle = '#2a2a2a';
                this.ctx.lineWidth = 0.5;
                for (let r = inner; r <= radius; r += (radius - inner) / 4) {
                    this.ctx.beginPath();
                    this.ctx.arc(cx, cy, r, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                for (let a = 0; a < 360; a += 30) {
                    const rad = (a - 90) * Math.PI / 180;
                    this.ctx.beginPath();
                    this.ctx.moveTo(cx + Math.cos(rad) * inner, cy + Math.sin(rad) * inner);
                    this.ctx.lineTo(cx + Math.cos(rad) * radius, cy + Math.sin(rad) * radius);
                    this.ctx.stroke();
                }
                
                // Data
                for (let i = 0; i < binData.bins.length; i++) {
                    const bin = binData.bins[i];
                    const count = bin.filter(idx => filteredIndices[idx]).length;
                    if (count < 1) continue;
                    
                    const start = (i * binData.binSize - 90) * Math.PI / 180;
                    const end = ((i + 1) * binData.binSize - 90) * Math.PI / 180;
                    const scale = (count / binData.maxCount) * (radius - inner);
                    
                    this.ctx.fillStyle = '#4a9eff';
                    this.ctx.beginPath();
                    this.ctx.arc(cx, cy, inner, start, end);
                    this.ctx.arc(cx, cy, inner + scale, end, start, true);
                    this.ctx.closePath();
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }
            
            onMouseDown(e) {
                const p = this.getMousePos(e);
                const cx = this.width / 2;
                const cy = this.height / 2;
                const dx = p.x - cx;
                const dy = p.y - cy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const radius = Math.min(cx, cy) - 20;
                
                if (dist >= radius * 0.3 && dist <= radius) {
                    const ang = Math.atan2(dy, dx) * 180 / Math.PI + 90;
                    const binData = binCache[this.column];
                    this.isDragging = true;
                    this.dragStart = Math.floor(((ang + 360) % 360) / binData.binSize);
                }
            }
            
            onMouseMove(e) {
                if (!this.isDragging) return;
                
                const p = this.getMousePos(e);
                const cx = this.width / 2;
                const cy = this.height / 2;
                const dx = p.x - cx;
                const dy = p.y - cy;
                const ang = Math.atan2(dy, dx) * 180 / Math.PI + 90;
                const binData = binCache[this.column];
                const bin = Math.floor(((ang + 360) % 360) / binData.binSize);
                
                let s = this.dragStart;
                let t = bin;
                if (Math.abs(t - s) > binData.numBins / 2) {
                    if (s < t) s += binData.numBins;
                    else t += binData.numBins;
                }
                
                this.selection = [Math.min(s, t) % binData.numBins, Math.max(s, t) % binData.numBins];
                this.draw();
            }
            
            onMouseUp() {
                if (this.isDragging && this.selection) {
                    const binData = binCache[this.column];
                    const min = this.selection[0] * binData.binSize;
                    const max = (this.selection[1] + 1) * binData.binSize;
                    
                    FilterSystem.setFilter(this.column, [min, max]);
                }
                
                this.isDragging = false;
                setTimeout(() => { this.isInteracting = false; }, 100);
            }
            
            onClick(e) {
                if (!this.isInteracting) {
                    this.selection = null;
                    FilterSystem.clearFilter(this.column);
                    this.draw();
                }
            }
        }
        
        // ============================================================================
        // BAR CHART (for categorical data)
        // ============================================================================
        
        class BarChart extends BaseChart {
            constructor(canvasId, column) {
                super(canvasId, column);
                this.margin = { top: 20, right: 10, bottom: 40, left: 60 };
                this.selected = new Set();
            }
            
            draw() {
                this.clear();
                const binData = binCache[this.column];
                if (!binData) return;
                
                const width = this.width - this.margin.left - this.margin.right;
                const height = this.height - this.margin.top - this.margin.bottom;
                const barWidth = width / binData.uniqueValues.length;
                
                // Calculate filtered counts
                const filteredCounts = {};
                for (const val of binData.uniqueValues) {
                    filteredCounts[val] = 0;
                }
                
                for (let i = 0; i < totalRows; i++) {
                    if (filteredIndices[i]) {
                        filteredCounts[data[this.column][i]]++;
                    }
                }
                
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3'];
                
                this.ctx.save();
                this.ctx.translate(this.margin.left, this.margin.top);
                
                for (let i = 0; i < binData.uniqueValues.length; i++) {
                    const x = i * barWidth;
                    const value = binData.uniqueValues[i];
                    const totalCount = binData.counts[value];
                    const filteredCount = filteredCounts[value];
                    
                    const h = (totalCount / binData.maxCount) * height;
                    const fh = (filteredCount / binData.maxCount) * height;
                    
                    // Background bar
                    this.ctx.fillStyle = '#2a2a2a';
                    this.ctx.fillRect(x, height - h, barWidth - 2, h);
                    
                    // Filtered bar
                    const isSelected = this.selected.size === 0 || this.selected.has(value);
                    this.ctx.fillStyle = isSelected ? colors[i % colors.length] : '#444';
                    this.ctx.fillRect(x, height - fh, barWidth - 2, fh);
                    
                    // Selection border
                    if (this.selected.has(value)) {
                        this.ctx.strokeStyle = '#feca57';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(x - 1, height - h - 1, barWidth, h + 2);
                    }
                    
                    // Label
                    this.ctx.fillStyle = '#888';
                    this.ctx.font = '11px -apple-system, sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(value.toString(), x + barWidth / 2, height + 20);
                }
                
                this.ctx.restore();
            }
            
            onMouseDown(e) {
                const p = this.getMousePos(e);
                const x = p.x - this.margin.left;
                const y = p.y - this.margin.top;
                const width = this.width - this.margin.left - this.margin.right;
                const height = this.height - this.margin.top - this.margin.bottom;
                
                if (x >= 0 && x <= width && y >= 0 && y <= height) {
                    const binData = binCache[this.column];
                    const barWidth = width / binData.uniqueValues.length;
                    const barIndex = Math.floor(x / barWidth);
                    
                    if (barIndex >= 0 && barIndex < binData.uniqueValues.length) {
                        const value = binData.uniqueValues[barIndex];
                        
                        if (this.selected.has(value)) {
                            this.selected.delete(value);
                        } else {
                            this.selected.add(value);
                        }
                        
                        // Update filter
                        if (this.selected.size > 0 && this.selected.size < binData.uniqueValues.length) {
                            FilterSystem.setFilter(this.column, new Set(this.selected));
                        } else {
                            FilterSystem.clearFilter(this.column);
                        }
                        
                        this.draw();
                    }
                }
            }
        }
        
        // ============================================================================
        // EASY DATA EMBEDDING SYSTEM
        // ============================================================================
        
        function loadData(config) {
            // Simple data loading with automatic type inference
            if (!config.columns) {
                // Auto-infer columns from first data row
                const firstRow = config.data[0];
                config.columns = Object.keys(firstRow).map(key => ({
                    name: key,
                    type: inferType(config.data.map(row => row[key]))
                }));
            }
            
            if (!config.charts) {
                // Auto-generate charts for all columns
                config.charts = config.columns.map(col => ({
                    column: col.name,
                    title: col.name.charAt(0).toUpperCase() + col.name.slice(1) + ' Distribution'
                }));
            }
            
            DataProcessor.init(config);
        }
        
        function inferType(values) {
            const sample = values.slice(0, 1000); // Sample for performance
            
            // Check for time pattern (HH:MM or HH:MM:SS)
            if (sample.some(v => typeof v === 'string' && /^\d{1,2}:\d{2}(:\d{2})?$/.test(v))) {
                return 'time';
            }
            
            // Check for angle (0-360 range)
            if (sample.every(v => typeof v === 'number' && v >= 0 && v <= 360)) {
                return 'angle';
            }
            
            // Check for integers
            if (sample.every(v => Number.isInteger(v))) {
                return 'integer';
            }
            
            // Check for numbers
            if (sample.every(v => typeof v === 'number')) {
                return 'number';
            }
            
            // Default to string
            return 'string';
        }
        
        // ============================================================================
        // PUBLIC API
        // ============================================================================
        
        function resetAll() {
            FilterSystem.clearAll();
        }
        
        function exportCSV() {
            const headers = DataConfig.columns.map(col => col.name);
            const filteredData = [];
            
            for (let i = 0; i < totalRows; i++) {
                if (filteredIndices[i]) {
                    const row = headers.map(header => data[header][i]);
                    filteredData.push(row);
                }
            }
            
            const csvContent = [headers.join(','), ...filteredData.map(row => row.join(','))].join('\n');
            
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'filtered_data.csv';
            a.click();
            window.URL.revokeObjectURL(url);
        }
        
        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        document.addEventListener('DOMContentLoaded', () => {
            // Default sample data if none provided
            if (!DataConfig.data || DataConfig.data.length === 0) {
                // Generate sample data
                const sampleData = [];
                for (let i = 0; i < 10000; i++) {
                    sampleData.push({
                        age: Math.floor(Math.random() * 60) + 18,
                        salary: Math.floor(Math.random() * 100000) + 30000,
                        score: Math.random() * 100,
                        angle: Math.random() * 360,
                        department: ['Engineering', 'Sales', 'Marketing', 'HR', 'Finance'][Math.floor(Math.random() * 5)],
                        time: Math.floor(Math.random() * 24) + ':' + Math.floor(Math.random() * 60).toString().padStart(2, '0')
                    });
                }
                
                DataConfig = {
                    title: "Sample Data Explorer",
                    data: sampleData,
                    columns: [
                        { name: 'age', type: 'integer' },
                        { name: 'salary', type: 'integer' },
                        { name: 'score', type: 'number' },
                        { name: 'angle', type: 'angle' },
                        { name: 'department', type: 'string' },
                        { name: 'time', type: 'time' }
                    ],
                    charts: [
                        { column: 'age', title: 'Age Distribution' },
                        { column: 'salary', title: 'Salary Distribution' },
                        { column: 'score', title: 'Score Distribution' },
                        { column: 'angle', title: 'Angle Distribution' },
                        { column: 'department', title: 'Department Breakdown' },
                        { column: 'time', title: 'Time Distribution' }
                    ]
                };
            }
            
            loadData(DataConfig);
        });
    </script>
</body>
</html>
