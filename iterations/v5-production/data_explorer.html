<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Production Data Explorer - 3x3 Grid</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, sans-serif; background: #0a0a0a; color: #e0e0e0; overflow: hidden; }
        #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        .progress { width: 400px; height: 6px; background: #333; margin-top: 10px; border-radius: 3px; }
        .progress-bar { height: 100%; background: #4a9eff; transition: width 0.1s; border-radius: 3px; }
        #main { display: none; height: 100vh; padding: 8px; }
        .header { background: #1a1a1a; padding: 8px 16px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .stats { display: flex; gap: 15px; font-size: 13px; }
        .stats span { display: flex; align-items: center; gap: 5px; }
        .stats strong { color: #4a9eff; }
        button { background: #4a9eff; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px; transition: all 0.2s; }
        button:hover { background: #3a8eef; }
        button:active { transform: scale(0.95); }
        .grid { 
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            grid-template-rows: repeat(3, 1fr); 
            gap: 8px; 
            height: calc(100% - 80px); 
        }
        .panel { background: #1a1a1a; border-radius: 4px; padding: 8px; position: relative; }
        .panel-title { font-size: 13px; margin-bottom: 4px; font-weight: 500; }
        canvas { position: absolute; top: 28px; left: 8px; right: 8px; bottom: 8px; cursor: crosshair; }
        #tooltip { position: fixed; background: rgba(0,0,0,0.95); padding: 6px 10px; border-radius: 3px; font-size: 11px; pointer-events: none; display: none; z-index: 1000; border: 1px solid #333; }
    </style>
</head>
<body>
    <div id="loading">
        <div>Loading data...</div>
        <div class="progress"><div class="progress-bar" id="progress"></div></div>
        <div id="loadingStatus" style="margin-top: 8px; font-size: 12px; color: #999;"></div>
    </div>
    
    <div id="main">
        <div class="header">
            <h3 id="title">Production Data Explorer - 3x3 Grid</h3>
            <div class="stats">
                <span>Total: <strong id="totalCount">0</strong></span>
                <span>Filtered: <strong id="filteredCount">0</strong></span>
                <span>Selected: <strong id="percentFiltered">0%</strong></span>
            </div>
            <div style="display: flex; gap: 8px;">
                <button onclick="resetAll()">ðŸ”„ Reset All</button>
                <button onclick="exportCSV()">ðŸ’¾ Export CSV</button>
            </div>
        </div>
        
        <div class="grid">
            <!-- Row 1: Histogram - Histogram - Angle -->
            <div class="panel">
                <div class="panel-title" id="chart1-title">Chart 1</div>
                <canvas id="chart1"></canvas>
            </div>
            <div class="panel">
                <div class="panel-title" id="chart2-title">Chart 2</div>
                <canvas id="chart2"></canvas>
            </div>
            <div class="panel">
                <div class="panel-title" id="chart3-title">Chart 3</div>
                <canvas id="chart3"></canvas>
            </div>
            
            <!-- Row 2: Histogram - Histogram - Bar -->
            <div class="panel">
                <div class="panel-title" id="chart4-title">Chart 4</div>
                <canvas id="chart4"></canvas>
            </div>
            <div class="panel">
                <div class="panel-title" id="chart5-title">Chart 5</div>
                <canvas id="chart5"></canvas>
            </div>
            <div class="panel">
                <div class="panel-title" id="chart6-title">Chart 6</div>
                <canvas id="chart6"></canvas>
            </div>
            
            <!-- Row 3: Histogram - Bar - Bar -->
            <div class="panel">
                <div class="panel-title" id="chart7-title">Chart 7</div>
                <canvas id="chart7"></canvas>
            </div>
            <div class="panel">
                <div class="panel-title" id="chart8-title">Chart 8</div>
                <canvas id="chart8"></canvas>
            </div>
            <div class="panel">
                <div class="panel-title" id="chart9-title">Chart 9</div>
                <canvas id="chart9"></canvas>
            </div>
        </div>
    </div>
    
    <div id="tooltip"></div>
    
    <script>
        // ============================================================================
        // PRODUCTION DATA EXPLORER - 3x3 GRID LAYOUT
        // ============================================================================
        
        // Data configuration - easily embed your data here
        window.DataConfig = {
            title: "Production Data Explorer",
            data: [], // Your data goes here
            chartLayout: [
                // Row 1: hist, hist, angle
                { id: 'chart1', type: 'histogram', column: '', title: '' },
                { id: 'chart2', type: 'histogram', column: '', title: '' },
                { id: 'chart3', type: 'angle', column: '', title: '' },
                // Row 2: hist, hist, bar
                { id: 'chart4', type: 'histogram', column: '', title: '' },
                { id: 'chart5', type: 'histogram', column: '', title: '' },
                { id: 'chart6', type: 'bar', column: '', title: '' },
                // Row 3: hist, bar, bar
                { id: 'chart7', type: 'histogram', column: '', title: '' },
                { id: 'chart8', type: 'bar', column: '', title: '' },
                { id: 'chart9', type: 'bar', column: '', title: '' }
            ]
        };
        
        // Global variables for performance
        let data = {};
        let filteredIndices = null;
        let totalRows = 0;
        let binCache = {};
        let charts = {};
        let filters = {};
        
        // ============================================================================
        // PERFORMANCE UTILITIES
        // ============================================================================
        
        function formatCount(count) {
            if (count >= 1000000) return (count / 1000000).toFixed(1) + 'M';
            if (count >= 1000) return (count / 1000).toFixed(1) + 'K';
            return count.toString();
        }
        
        function formatValue(value, type) {
            if (type === 'time') {
                const hours = Math.floor(value / 3600);
                const minutes = Math.floor((value % 3600) / 60);
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            }
            if (type === 'angle') {
                return value.toFixed(1) + 'Â°';
            }
            if (typeof value === 'number') {
                return value.toLocaleString();
            }
            return value.toString();
        }
        
        // ============================================================================
        // HIGH-PERFORMANCE DATA PROCESSING
        // ============================================================================
        
        class DataProcessor {
            static init(config) {
                DataConfig = config;
                document.getElementById('title').textContent = config.title || 'Production Data Explorer';
                
                totalRows = config.data.length;
                
                // Extract unique columns from data
                const allColumns = new Set();
                config.data.forEach(row => {
                    Object.keys(row).forEach(key => allColumns.add(key));
                });
                
                // Convert to TypedArrays for maximum performance
                data = {};
                for (const col of allColumns) {
                    const values = config.data.map(row => row[col] || 0);
                    const colType = this.inferType(values);
                    
                    switch (colType) {
                        case 'integer':
                            data[col] = { values: new Int32Array(values), type: colType };
                            break;
                        case 'number':
                        case 'angle':
                        case 'time':
                            data[col] = { values: new Float32Array(values), type: colType };
                            break;
                        default:
                            data[col] = { values: values, type: colType };
                    }
                }
                
                // Initialize filters
                filteredIndices = new Uint8Array(totalRows);
                filteredIndices.fill(1);
                
                filters = {};
                for (const col of allColumns) {
                    filters[col] = null;
                }
                
                // Auto-assign columns to charts if not specified
                this.autoAssignColumns();
                
                // Pre-process data for charts
                this.prebinData();
                
                // Create UI
                this.createCharts();
                this.updateStats();
                
                // Show main interface
                document.getElementById('loading').style.display = 'none';
                document.getElementById('main').style.display = 'block';
            }
            
            static inferType(values) {
                const sample = values.slice(0, 1000);
                
                // Check for time pattern
                if (sample.some(v => typeof v === 'string' && /^\d{1,2}:\d{2}(:\d{2})?$/.test(v))) {
                    return 'time';
                }
                
                // Check for angle (0-360 range)
                if (sample.every(v => typeof v === 'number' && v >= 0 && v <= 360)) {
                    return 'angle';
                }
                
                // Check for integers
                if (sample.every(v => Number.isInteger(v))) {
                    return 'integer';
                }
                
                // Check for numbers
                if (sample.every(v => typeof v === 'number')) {
                    return 'number';
                }
                
                return 'string';
            }
            
            static autoAssignColumns() {
                const columns = Object.keys(data);
                const histogramCols = columns.filter(col => 
                    ['number', 'integer', 'time'].includes(data[col].type)
                );
                const angleCols = columns.filter(col => data[col].type === 'angle');
                const barCols = columns.filter(col => data[col].type === 'string');
                
                let histIdx = 0, angleIdx = 0, barIdx = 0;
                
                DataConfig.chartLayout.forEach(chart => {
                    if (!chart.column) {
                        if (chart.type === 'histogram' && histIdx < histogramCols.length) {
                            chart.column = histogramCols[histIdx++];
                            chart.title = chart.column.replace('_', ' ').toUpperCase();
                        } else if (chart.type === 'angle' && angleIdx < angleCols.length) {
                            chart.column = angleCols[angleIdx++];
                            chart.title = chart.column.replace('_', ' ').toUpperCase();
                        } else if (chart.type === 'bar' && barIdx < barCols.length) {
                            chart.column = barCols[barIdx++];
                            chart.title = chart.column.replace('_', ' ').toUpperCase();
                        } else {
                            // Fallback: use any available column
                            const availableCol = columns[Math.floor(Math.random() * columns.length)];
                            chart.column = availableCol;
                            chart.title = availableCol.replace('_', ' ').toUpperCase();
                        }
                    }
                });
            }
            
            static prebinData() {
                binCache = {};
                
                for (const col of Object.keys(data)) {
                    const colData = data[col];
                    const values = colData.values;
                    const type = colData.type;
                    
                    if (type === 'number' || type === 'integer' || type === 'time') {
                        // Histogram binning - safe min/max calculation to avoid stack overflow
                        let min = values[0];
                        let max = values[0];
                        for (let i = 1; i < values.length; i++) {
                            if (values[i] < min) min = values[i];
                            if (values[i] > max) max = values[i];
                        }
                        
                        const numBins = 50;
                        const binSize = (max - min) / numBins || 1; // Avoid division by zero
                        
                        const bins = Array(numBins).fill().map(() => []);
                        for (let i = 0; i < values.length; i++) {
                            const binIndex = Math.min(Math.floor((values[i] - min) / binSize), numBins - 1);
                            bins[binIndex].push(i);
                        }
                        
                        // Safe maxCount calculation
                        let maxCount = 0;
                        for (let i = 0; i < bins.length; i++) {
                            if (bins[i].length > maxCount) {
                                maxCount = bins[i].length;
                            }
                        }
                        
                        binCache[col] = {
                            type: 'histogram',
                            bins,
                            min,
                            max,
                            binSize,
                            numBins,
                            maxCount
                        };
                    }
                    else if (type === 'angle') {
                        // Angle binning (36 bins = 10 degrees each)
                        const numBins = 36;
                        const binSize = 10;
                        
                        const bins = Array(numBins).fill().map(() => []);
                        for (let i = 0; i < values.length; i++) {
                            const binIndex = Math.floor(values[i] / binSize) % numBins;
                            bins[binIndex].push(i);
                        }
                        
                        // Safe maxCount calculation
                        let maxCount = 0;
                        for (let i = 0; i < bins.length; i++) {
                            if (bins[i].length > maxCount) {
                                maxCount = bins[i].length;
                            }
                        }
                        
                        binCache[col] = {
                            type: 'angle',
                            bins,
                            min: 0,
                            max: 360,
                            binSize,
                            numBins,
                            maxCount
                        };
                    }
                    else if (type === 'string') {
                        // Categorical binning
                        const uniqueValues = [...new Set(values)];
                        if (uniqueValues.length <= 20) {
                            const counts = {};
                            for (const val of uniqueValues) {
                                counts[val] = 0;
                            }
                            for (const val of values) {
                                counts[val]++;
                            }
                            
                            // Safe maxCount calculation
                            let maxCount = 0;
                            for (const val of uniqueValues) {
                                if (counts[val] > maxCount) {
                                    maxCount = counts[val];
                                }
                            }
                            
                            binCache[col] = {
                                type: 'categorical',
                                uniqueValues,
                                counts,
                                maxCount
                            };
                        }
                    }
                }
            }
            
            static createCharts() {
                for (const chartConfig of DataConfig.chartLayout) {
                    // Set title
                    document.getElementById(chartConfig.id + '-title').textContent = chartConfig.title;
                    
                    // Create chart instance
                    const binData = binCache[chartConfig.column];
                    if (binData) {
                        if (chartConfig.type === 'histogram') {
                            charts[chartConfig.id] = new HistogramChart(chartConfig.id, chartConfig.column);
                        } else if (chartConfig.type === 'angle') {
                            charts[chartConfig.id] = new AngleChart(chartConfig.id, chartConfig.column);
                        } else if (chartConfig.type === 'bar') {
                            charts[chartConfig.id] = new BarChart(chartConfig.id, chartConfig.column);
                        }
                    }
                }
            }
            
            static updateStats() {
                const filteredCount = filteredIndices.reduce((sum, val) => sum + val, 0);
                const percent = totalRows > 0 ? ((filteredCount / totalRows) * 100).toFixed(1) : 0;
                
                document.getElementById('totalCount').textContent = formatCount(totalRows);
                document.getElementById('filteredCount').textContent = formatCount(filteredCount);
                document.getElementById('percentFiltered').textContent = percent + '%';
            }
        }
        
        // ============================================================================
        // FILTER SYSTEM
        // ============================================================================
        
        class FilterSystem {
            static applyFilters() {
                const newIndices = new Uint8Array(totalRows);
                newIndices.fill(1);
                
                // Apply all active filters
                for (const [column, filter] of Object.entries(filters)) {
                    if (!filter || !data[column]) continue;
                    
                    const values = data[column].values;
                    
                    if (Array.isArray(filter)) {
                        // Range filter
                        const [min, max] = filter;
                        for (let i = 0; i < totalRows; i++) {
                            if (newIndices[i] && (values[i] < min || values[i] > max)) {
                                newIndices[i] = 0;
                            }
                        }
                    } else if (filter instanceof Set) {
                        // Categorical filter
                        for (let i = 0; i < totalRows; i++) {
                            if (newIndices[i] && !filter.has(values[i])) {
                                newIndices[i] = 0;
                            }
                        }
                    }
                }
                
                filteredIndices = newIndices;
                DataProcessor.updateStats();
                this.updateAllCharts();
            }
            
            static setFilter(column, filterValue) {
                filters[column] = filterValue;
                this.applyFilters();
            }
            
            static clearFilter(column) {
                filters[column] = null;
                this.applyFilters();
            }
            
            static clearAll() {
                for (const col of Object.keys(filters)) {
                    filters[col] = null;
                }
                filteredIndices.fill(1);
                DataProcessor.updateStats();
                this.updateAllCharts();
            }
            
            static updateAllCharts() {
                Object.values(charts).forEach(chart => chart.draw());
            }
        }
        
        // ============================================================================
        // HIGH-PERFORMANCE CHART CLASSES
        // ============================================================================
        
        class BaseChart {
            constructor(canvasId, column) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.column = column;
                this.width = 0;
                this.height = 0;
                
                this.setupCanvas();
                this.setupEvents();
                window.addEventListener('resize', this.resize.bind(this));
            }
            
            setupCanvas() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = (rect.width - 16) * dpr;
                this.canvas.height = (rect.height - 36) * dpr;
                this.canvas.style.width = (rect.width - 16) + 'px';
                this.canvas.style.height = (rect.height - 36) + 'px';
                this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                this.width = rect.width - 16;
                this.height = rect.height - 36;
                this.draw();
            }
            
            resize() {
                this.setupCanvas();
            }
            
            clear() {
                this.ctx.fillStyle = '#1a1a1a';
                this.ctx.fillRect(0, 0, this.width, this.height);
            }
            
            getMousePos(e) {
                if (!e || !this.canvas) return { x: 0, y: 0 };
                const r = this.canvas.getBoundingClientRect();
                return {
                    x: (e.clientX - r.left) * (this.width / r.width),
                    y: (e.clientY - r.top) * (this.height / r.height)
                };
            }
            
            setupEvents() {
                this.canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                this.canvas.addEventListener('click', this.onClick.bind(this));
            }
            
            onMouseDown(e) {}
            onMouseMove(e) {}
            onMouseUp(e) {}
            onClick(e) {}
            draw() {}
        }
        
        // ============================================================================
        // HISTOGRAM CHART
        // ============================================================================
        
        class HistogramChart extends BaseChart {
            constructor(canvasId, column) {
                super(canvasId, column);
                this.margin = { top: 10, right: 10, bottom: 25, left: 35 };
                this.isDragging = false;
                this.dragStart = 0;
                this.selection = null;
                this.isInteracting = false;
            }
            
            draw() {
                this.clear();
                const binData = binCache[this.column];
                if (!binData) return;
                
                const width = this.width - this.margin.left - this.margin.right;
                const height = this.height - this.margin.top - this.margin.bottom;
                const barWidth = width / binData.bins.length;
                
                // Calculate counts with performance optimization
                const counts = new Float32Array(binData.bins.length);
                const filteredCounts = new Float32Array(binData.bins.length);
                
                for (let i = 0; i < binData.bins.length; i++) {
                    const bin = binData.bins[i];
                    counts[i] = bin.length;
                    
                    // Performance optimization for large bins
                    if (bin.length > 1000) {
                        let sampled = 0;
                        const step = Math.max(1, Math.floor(bin.length / 1000));
                        for (let j = 0; j < bin.length && sampled < 1000; j += step) {
                            if (filteredIndices[bin[j]]) sampled++;
                        }
                        filteredCounts[i] = (sampled / Math.min(1000, bin.length)) * bin.length;
                    } else {
                        filteredCounts[i] = bin.filter(idx => filteredIndices[idx]).length;
                    }
                }
                
                const maxCount = binData.maxCount;
                
                this.ctx.save();
                this.ctx.translate(this.margin.left, this.margin.top);
                
                // Draw bars
                for (let i = 0; i < binData.bins.length; i++) {
                    const x = i * barWidth;
                    const h = (counts[i] / maxCount) * height;
                    const fh = (filteredCounts[i] / maxCount) * height;
                    
                    // Background bar
                    this.ctx.fillStyle = '#2a2a2a';
                    this.ctx.fillRect(x, height - h, barWidth - 1, h);
                    
                    // Filtered bar
                    this.ctx.fillStyle = '#4a9eff';
                    this.ctx.fillRect(x, height - fh, barWidth - 1, fh);
                }
                
                // Selection overlay
                if (this.selection) {
                    this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
                    this.ctx.strokeStyle = '#feca57';
                    this.ctx.lineWidth = 2;
                    const x1 = this.selection[0] * barWidth;
                    const x2 = (this.selection[1] + 1) * barWidth;
                    this.ctx.fillRect(x1, 0, x2 - x1, height);
                    this.ctx.strokeRect(x1, 0, x2 - x1, height);
                }
                
                // Axes
                this.ctx.strokeStyle = '#444';
                this.ctx.beginPath();
                this.ctx.moveTo(0, height);
                this.ctx.lineTo(width, height);
                this.ctx.moveTo(0, 0);
                this.ctx.lineTo(0, height);
                this.ctx.stroke();
                
                this.ctx.restore();
            }
            
            onMouseDown(e) {
                if (!e) return;
                const p = this.getMousePos(e);
                if (!p || !this.margin) return;
                
                const x = p.x - this.margin.left;
                const width = this.width - this.margin.left - this.margin.right;
                
                if (x >= 0 && x <= width && p.y >= this.margin.top && p.y <= this.height - this.margin.bottom) {
                    const binData = binCache[this.column];
                    if (!binData || !binData.bins) return;
                    
                    const bin = Math.floor(x / (width / binData.bins.length));
                    
                    if (bin >= 0 && bin < binData.bins.length) {
                        this.isDragging = true;
                        this.isInteracting = true;
                        this.dragStart = bin;
                    }
                }
            }
            
            onMouseMove(e) {
                if (!this.isDragging || !e) return;
                
                const p = this.getMousePos(e);
                if (!p || !this.margin) return;
                
                const x = p.x - this.margin.left;
                const width = this.width - this.margin.left - this.margin.right;
                
                if (x >= 0 && x <= width) {
                    const binData = binCache[this.column];
                    if (!binData || !binData.bins) return;
                    
                    const bin = Math.floor(x / (width / binData.bins.length));
                    if (bin >= 0 && bin < binData.bins.length) {
                        this.selection = [Math.min(this.dragStart, bin), Math.max(this.dragStart, bin)];
                        this.draw();
                    }
                }
            }
            
            onMouseUp() {
                if (this.isDragging && this.selection) {
                    const binData = binCache[this.column];
                    if (binData && binData.binSize !== undefined && binData.min !== undefined) {
                        const min = binData.min + this.selection[0] * binData.binSize;
                        const max = binData.min + (this.selection[1] + 1) * binData.binSize;
                        
                        FilterSystem.setFilter(this.column, [min, max]);
                    }
                }
                
                this.isDragging = false;
                setTimeout(() => { this.isInteracting = false; }, 100);
            }
            
            onClick(e) {
                if (!this.isInteracting) {
                    this.selection = null;
                    FilterSystem.clearFilter(this.column);
                    this.draw();
                }
            }
        }
        
        // ============================================================================
        // ANGLE CHART
        // ============================================================================
        
        class AngleChart extends BaseChart {
            constructor(canvasId, column) {
                super(canvasId, column);
                this.isDragging = false;
                this.selection = null;
                this.isInteracting = false;
            }
            
            draw() {
                this.clear();
                const binData = binCache[this.column];
                if (!binData) return;
                
                const cx = this.width / 2;
                const cy = this.height / 2;
                const radius = Math.min(cx, cy) - 15;
                const inner = radius * 0.3;
                
                this.ctx.save();
                
                // Grid
                this.ctx.strokeStyle = '#2a2a2a';
                this.ctx.lineWidth = 0.5;
                for (let r = inner; r <= radius; r += (radius - inner) / 4) {
                    this.ctx.beginPath();
                    this.ctx.arc(cx, cy, r, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                for (let a = 0; a < 360; a += 45) {
                    const rad = (a - 90) * Math.PI / 180;
                    this.ctx.beginPath();
                    this.ctx.moveTo(cx + Math.cos(rad) * inner, cy + Math.sin(rad) * inner);
                    this.ctx.lineTo(cx + Math.cos(rad) * radius, cy + Math.sin(rad) * radius);
                    this.ctx.stroke();
                }
                
                // Data
                for (let i = 0; i < binData.bins.length; i++) {
                    const bin = binData.bins[i];
                    const count = bin.filter(idx => filteredIndices[idx]).length;
                    if (count < 1) continue;
                    
                    const start = (i * binData.binSize - 90) * Math.PI / 180;
                    const end = ((i + 1) * binData.binSize - 90) * Math.PI / 180;
                    const scale = (count / binData.maxCount) * (radius - inner);
                    
                    this.ctx.fillStyle = '#4a9eff';
                    this.ctx.beginPath();
                    this.ctx.arc(cx, cy, inner, start, end);
                    this.ctx.arc(cx, cy, inner + scale, end, start, true);
                    this.ctx.closePath();
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }
            
            onMouseDown(e) {
                if (!e) return;
                const p = this.getMousePos(e);
                if (!p) return;
                
                const cx = this.width / 2;
                const cy = this.height / 2;
                const dx = p.x - cx;
                const dy = p.y - cy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const radius = Math.min(cx, cy) - 15;
                
                if (dist >= radius * 0.3 && dist <= radius) {
                    const ang = Math.atan2(dy, dx) * 180 / Math.PI + 90;
                    const binData = binCache[this.column];
                    if (binData && binData.binSize) {
                        this.isDragging = true;
                        this.dragStart = Math.floor(((ang + 360) % 360) / binData.binSize);
                    }
                }
            }
            
            onMouseMove(e) {
                if (!this.isDragging || !e) return;
                
                const p = this.getMousePos(e);
                if (!p) return;
                
                const cx = this.width / 2;
                const cy = this.height / 2;
                const dx = p.x - cx;
                const dy = p.y - cy;
                const ang = Math.atan2(dy, dx) * 180 / Math.PI + 90;
                const binData = binCache[this.column];
                
                if (binData && binData.binSize) {
                    const bin = Math.floor(((ang + 360) % 360) / binData.binSize);
                    this.selection = [this.dragStart, bin];
                    this.draw();
                }
            }
            
            onMouseUp() {
                if (this.isDragging && this.selection) {
                    const binData = binCache[this.column];
                    if (binData && binData.binSize !== undefined) {
                        const min = this.selection[0] * binData.binSize;
                        const max = (this.selection[1] + 1) * binData.binSize;
                        
                        FilterSystem.setFilter(this.column, [min, max]);
                    }
                }
                
                this.isDragging = false;
                setTimeout(() => { this.isInteracting = false; }, 100);
            }
            
            onClick(e) {
                if (!this.isInteracting) {
                    this.selection = null;
                    FilterSystem.clearFilter(this.column);
                    this.draw();
                }
            }
        }
        
        // ============================================================================
        // BAR CHART
        // ============================================================================
        
        class BarChart extends BaseChart {
            constructor(canvasId, column) {
                super(canvasId, column);
                this.margin = { top: 15, right: 10, bottom: 30, left: 40 };
                this.selected = new Set();
            }
            
            draw() {
                this.clear();
                const binData = binCache[this.column];
                if (!binData) return;
                
                const width = this.width - this.margin.left - this.margin.right;
                const height = this.height - this.margin.top - this.margin.bottom;
                const barWidth = width / binData.uniqueValues.length;
                
                // Calculate filtered counts
                const filteredCounts = {};
                for (const val of binData.uniqueValues) {
                    filteredCounts[val] = 0;
                }
                
                const values = data[this.column].values;
                for (let i = 0; i < totalRows; i++) {
                    if (filteredIndices[i]) {
                        filteredCounts[values[i]]++;
                    }
                }
                
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#a8e6cf', '#dda0dd'];
                
                this.ctx.save();
                this.ctx.translate(this.margin.left, this.margin.top);
                
                for (let i = 0; i < binData.uniqueValues.length; i++) {
                    const x = i * barWidth;
                    const value = binData.uniqueValues[i];
                    const totalCount = binData.counts[value];
                    const filteredCount = filteredCounts[value];
                    
                    const h = (totalCount / binData.maxCount) * height;
                    const fh = (filteredCount / binData.maxCount) * height;
                    
                    // Background bar
                    this.ctx.fillStyle = '#2a2a2a';
                    this.ctx.fillRect(x, height - h, barWidth - 2, h);
                    
                    // Filtered bar
                    const isSelected = this.selected.size === 0 || this.selected.has(value);
                    this.ctx.fillStyle = isSelected ? colors[i % colors.length] : '#444';
                    this.ctx.fillRect(x, height - fh, barWidth - 2, fh);
                    
                    // Selection border
                    if (this.selected.has(value)) {
                        this.ctx.strokeStyle = '#feca57';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(x - 1, height - h - 1, barWidth, h + 2);
                    }
                    
                    // Label (truncated if too long)
                    this.ctx.fillStyle = '#888';
                    this.ctx.font = '9px -apple-system, sans-serif';
                    this.ctx.textAlign = 'center';
                    let label = value.toString();
                    if (label.length > 8) label = label.substring(0, 6) + '..';
                    this.ctx.fillText(label, x + barWidth / 2, height + 15);
                }
                
                this.ctx.restore();
            }
            
            onMouseDown(e) {
                if (!e) return;
                const p = this.getMousePos(e);
                if (!p || !this.margin) return;
                
                const x = p.x - this.margin.left;
                const y = p.y - this.margin.top;
                const width = this.width - this.margin.left - this.margin.right;
                const height = this.height - this.margin.top - this.margin.bottom;
                
                if (x >= 0 && x <= width && y >= 0 && y <= height) {
                    const binData = binCache[this.column];
                    if (!binData || !binData.uniqueValues) return;
                    
                    const barWidth = width / binData.uniqueValues.length;
                    const barIndex = Math.floor(x / barWidth);
                    
                    if (barIndex >= 0 && barIndex < binData.uniqueValues.length) {
                        const value = binData.uniqueValues[barIndex];
                        
                        if (this.selected.has(value)) {
                            this.selected.delete(value);
                        } else {
                            this.selected.add(value);
                        }
                        
                        // Update filter
                        if (this.selected.size > 0 && this.selected.size < binData.uniqueValues.length) {
                            FilterSystem.setFilter(this.column, new Set(this.selected));
                        } else {
                            FilterSystem.clearFilter(this.column);
                        }
                        
                        this.draw();
                    }
                }
            }
        }
        
        // ============================================================================
        // PUBLIC API
        // ============================================================================
        
        function resetAll() {
            FilterSystem.clearAll();
            // Clear all chart selections
            Object.values(charts).forEach(chart => {
                if (chart.selected) chart.selected.clear();
                if (chart.selection) chart.selection = null;
                chart.draw();
            });
        }
        
        function exportCSV() {
            const headers = Object.keys(data);
            const filteredData = [];
            
            for (let i = 0; i < totalRows; i++) {
                if (filteredIndices[i]) {
                    const row = headers.map(header => data[header].values[i]);
                    filteredData.push(row);
                }
            }
            
            const csvContent = [headers.join(','), ...filteredData.map(row => row.join(','))].join('\n');
            
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'filtered_data.csv';
            a.click();
            window.URL.revokeObjectURL(url);
        }
        
        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        document.addEventListener('DOMContentLoaded', () => {
            // Default sample data if none provided
            if (!DataConfig.data || DataConfig.data.length === 0) {
                // Generate comprehensive sample data with 9 different columns
                const sampleData = [];
                const departments = ['Engineering', 'Sales', 'Marketing', 'HR', 'Finance'];
                const locations = ['NYC', 'SF', 'LA', 'Chicago', 'Boston'];
                const teams = ['Alpha', 'Beta', 'Gamma', 'Delta'];
                
                for (let i = 0; i < 50000; i++) {
                    sampleData.push({
                        age: Math.floor(Math.random() * 45) + 22,           // histogram
                        salary: Math.floor(Math.random() * 120000) + 40000, // histogram
                        angle: Math.random() * 360,                         // angle chart
                        experience: Math.floor(Math.random() * 20) + 1,     // histogram
                        score: Math.random() * 100,                         // histogram
                        department: departments[Math.floor(Math.random() * departments.length)], // bar
                        rating: Math.floor(Math.random() * 25) + 75,        // histogram
                        location: locations[Math.floor(Math.random() * locations.length)],     // bar
                        team: teams[Math.floor(Math.random() * teams.length)]                   // bar
                    });
                }
                
                DataConfig = {
                    title: "Production Data Explorer - 3x3 Grid",
                    data: sampleData,
                    chartLayout: [
                        // Row 1: hist, hist, angle
                        { id: 'chart1', type: 'histogram', column: 'age', title: 'AGE DISTRIBUTION' },
                        { id: 'chart2', type: 'histogram', column: 'salary', title: 'SALARY DISTRIBUTION' },
                        { id: 'chart3', type: 'angle', column: 'angle', title: 'ANGLE DISTRIBUTION' },
                        // Row 2: hist, hist, bar
                        { id: 'chart4', type: 'histogram', column: 'experience', title: 'EXPERIENCE DISTRIBUTION' },
                        { id: 'chart5', type: 'histogram', column: 'score', title: 'SCORE DISTRIBUTION' },
                        { id: 'chart6', type: 'bar', column: 'department', title: 'DEPARTMENT BREAKDOWN' },
                        // Row 3: hist, bar, bar
                        { id: 'chart7', type: 'histogram', column: 'rating', title: 'RATING DISTRIBUTION' },
                        { id: 'chart8', type: 'bar', column: 'location', title: 'LOCATION BREAKDOWN' },
                        { id: 'chart9', type: 'bar', column: 'team', title: 'TEAM BREAKDOWN' }
                    ]
                };
            }
            
            DataProcessor.init(DataConfig);
        });
    </script>
</body>
</html>
