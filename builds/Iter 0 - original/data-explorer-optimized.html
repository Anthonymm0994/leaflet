<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline Arrow Data Explorer</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        :root {
            /* Light mode colors */
            --bg-primary: #ffffff;
            --bg-secondary: #f3f4f6;
            --bg-tertiary: #e5e7eb;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --text-tertiary: #9ca3af;
            --border-color: #e5e7eb;
            --primary-color: #2563eb;
            --primary-hover: #1d4ed8;
            --success-color: #10b981;
            --error-color: #ef4444;
            --warning-color: #f59e0b;
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        
        [data-theme="dark"] {
            /* Dark mode colors */
            --bg-primary: #1f2937;
            --bg-secondary: #111827;
            --bg-tertiary: #374151;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-tertiary: #9ca3af;
            --border-color: #374151;
            --primary-color: #3b82f6;
            --primary-hover: #2563eb;
            --success-color: #34d399;
            --error-color: #f87171;
            --warning-color: #fbbf24;
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.3), 0 1px 2px 0 rgba(0, 0, 0, 0.2);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
        }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-secondary);
            color: var(--text-primary);
            line-height: 1.6;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .container { 
            max-width: 1600px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        .header { 
            background: var(--bg-primary); 
            padding: 24px; 
            border-radius: 12px; 
            box-shadow: var(--shadow);
            margin-bottom: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
        }
        
        .header-content {
            flex: 1;
        }
        
        .header h1 {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .header p {
            color: var(--text-secondary);
            font-size: 16px;
        }
        
        .theme-toggle {
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
        }
        
        .theme-toggle:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            transform: scale(1.05);
        }
        
        .status-bar {
            display: flex;
            align-items: center;
            gap: 24px;
            margin-top: 16px;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            font-size: 14px;
            flex-wrap: wrap;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--warning-color);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .status-dot.ready { 
            background: var(--success-color);
            animation: none;
        }
        
        .status-dot.error { 
            background: var(--error-color);
            animation: none;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 24px;
        }
        
        @media (min-width: 1200px) {
            .main-content {
                grid-template-columns: 400px 1fr;
            }
        }
        
        .panel {
            background: var(--bg-primary);
            padding: 24px;
            border-radius: 12px;
            box-shadow: var(--shadow);
            transition: all 0.3s ease;
        }
        
        .panel:hover {
            box-shadow: var(--shadow-lg);
        }
        
        .panel h2 {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .sql-editor-wrapper {
            position: relative;
            margin-bottom: 16px;
        }
        
        .sql-editor {
            width: 100%;
            min-height: 120px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            padding: 16px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            resize: vertical;
            transition: all 0.2s;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .sql-editor:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }
        
        .editor-hints {
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 12px;
            color: var(--text-tertiary);
            background: var(--bg-primary);
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }
        
        .btn:hover:not(:disabled) { 
            background: var(--primary-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }
        
        .btn:active:not(:disabled) {
            transform: translateY(0);
        }
        
        .btn:disabled { 
            background: var(--text-tertiary); 
            cursor: not-allowed;
            transform: none;
            opacity: 0.6;
        }
        
        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: var(--bg-secondary);
            border-color: var(--primary-color);
        }
        
        .select-wrapper {
            position: relative;
            display: inline-block;
        }
        
        select {
            appearance: none;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            padding: 10px 40px 10px 16px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-primary);
        }
        
        select:hover:not(:disabled) {
            border-color: var(--primary-color);
            background: var(--bg-secondary);
        }
        
        select:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .select-arrow {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            color: var(--text-secondary);
        }
        
        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .tab {
            padding: 12px 24px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.2s;
            position: relative;
            border-radius: 8px 8px 0 0;
            white-space: nowrap;
        }
        
        .tab:hover {
            color: var(--text-primary);
            background: var(--bg-tertiary);
        }
        
        .tab.active {
            color: var(--primary-color);
            background: var(--bg-tertiary);
        }
        
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--primary-color);
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: var(--bg-tertiary);
            padding: 16px;
            border-radius: 8px;
            text-align: center;
            transition: all 0.2s;
        }
        
        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 4px;
        }
        
        .stat-label {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .chart-container {
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 24px;
            position: relative;
        }
        
        .chart-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }
        
        .chart-select {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .chart-select label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
        }
        
        /* Virtual scroll table styles */
        .virtual-table {
            height: 500px;
            overflow: hidden;
            position: relative;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-primary);
        }
        
        .virtual-table-header {
            position: sticky;
            top: 0;
            z-index: 10;
            background: var(--bg-tertiary);
            border-bottom: 2px solid var(--border-color);
        }
        
        .virtual-table-body {
            height: calc(100% - 48px);
            overflow-y: auto;
            position: relative;
        }
        
        .virtual-table-viewport {
            position: relative;
        }
        
        .virtual-table-row {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.1s;
        }
        
        .virtual-table-row:hover {
            background: var(--bg-tertiary);
        }
        
        .virtual-table-cell {
            padding: 12px 16px;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .virtual-table-header .virtual-table-cell {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.3s ease;
        }
        
        #loading-overlay.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-content {
            text-align: center;
            max-width: 400px;
        }
        
        .loading-logo {
            font-size: 64px;
            margin-bottom: 24px;
            animation: bounce 1.5s ease-in-out infinite;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        
        .loading-text {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }
        
        .loading-subtext {
            font-size: 16px;
            color: var(--text-secondary);
            margin-bottom: 24px;
        }
        
        .loading-progress {
            width: 100%;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 16px;
        }
        
        .loading-progress-bar {
            height: 100%;
            background: var(--primary-color);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }
        
        .loading-details {
            font-size: 14px;
            color: var(--text-tertiary);
        }
        
        .error-message {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--error-color);
            color: var(--error-color);
            padding: 16px;
            border-radius: 8px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 16px 0;
        }
        
        .success-message {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid var(--success-color);
            color: var(--success-color);
            padding: 16px;
            border-radius: 8px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 16px 0;
        }
        
        /* Responsive improvements */
        @media (max-width: 768px) {
            .container {
                padding: 12px;
            }
            
            .header {
                flex-direction: column;
                align-items: stretch;
            }
            
            .theme-toggle {
                align-self: flex-end;
            }
            
            .panel {
                padding: 16px;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .btn, select {
                width: 100%;
            }
            
            .result-stats {
                grid-template-columns: 1fr;
            }
            
            .chart-controls {
                grid-template-columns: 1fr;
            }
        }
        
        /* Print styles */
        @media print {
            body {
                background: white;
                color: black;
            }
            
            .theme-toggle,
            .controls,
            #loading-overlay {
                display: none !important;
            }
        }
        
        /* Focus styles for accessibility */
        :focus-visible {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }
        
        /* Smooth scrolling */
        html {
            scroll-behavior: smooth;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--text-tertiary);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }
    </style>
</head>
<body data-theme="dark">
    <div id="loading-overlay">
        <div class="loading-content">
            <div class="loading-logo">📊</div>
            <div class="loading-text">Initializing Data Explorer</div>
            <div class="loading-subtext">Preparing your offline experience...</div>
            <div class="loading-progress">
                <div class="loading-progress-bar" id="loadingProgress"></div>
            </div>
            <div class="loading-details" id="loadingDetails">Loading dependencies...</div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <div class="header-content">
                <h1>
                    <span>📊</span>
                    Offline Arrow Data Explorer
                </h1>
                <p>Query and visualize Arrow data directly in your browser - 100% offline</p>
                <div class="status-bar">
                    <div class="status-indicator">
                        <div id="status-dot" class="status-dot"></div>
                        <span id="status-text">Initializing...</span>
                    </div>
                    <div class="status-indicator">
                        <span class="stat-label">Data:</span>
                        <span id="data-info" class="stat-value">-</span>
                    </div>
                    <div class="status-indicator">
                        <span class="stat-label">Engine:</span>
                        <span class="stat-value">DuckDB-WASM</span>
                    </div>
                    <div class="status-indicator">
                        <span class="stat-label">Mode:</span>
                        <span class="stat-value">100% Offline</span>
                    </div>
                </div>
            </div>
            <button id="themeToggle" class="theme-toggle" aria-label="Toggle theme">
                <span id="themeIcon">🌙</span>
            </button>
        </div>

        <div class="main-content">
            <div class="panel">
                <h2>
                    <span>🔍</span>
                    SQL Query
                </h2>
                <div class="sql-editor-wrapper">
                    <textarea id="sqlEditor" class="sql-editor" placeholder="Enter your SQL query here...">SELECT * FROM arrow_data LIMIT 100</textarea>
                    <div class="editor-hints">Ctrl+Enter to run</div>
                </div>
                <div class="controls">
                    <button id="runQuery" class="btn" disabled>
                        <span>▶</span>
                        Run Query
                    </button>
                    <button id="clearQuery" class="btn btn-secondary" disabled>
                        <span>✕</span>
                        Clear
                    </button>
                </div>
                
                <div style="margin-top: 20px;">
                    <h3 style="font-size: 16px; margin-bottom: 12px; color: var(--text-secondary);">Quick Queries</h3>
                    <div class="select-wrapper" style="width: 100%;">
                        <select id="presetQueries" style="width: 100%;" disabled>
                            <option value="">Select a preset query...</option>
                            <option value="SELECT * FROM arrow_data LIMIT 100">First 100 rows</option>
                            <option value="SELECT COUNT(*) as total_rows FROM arrow_data">Count total rows</option>
                            <option value="DESCRIBE arrow_data">Show table schema</option>
                            <option value="SELECT * FROM arrow_data WHERE 1=0">Schema only (no data)</option>
                        </select>
                        <span class="select-arrow">▼</span>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2>
                    <span>📋</span>
                    Results
                </h2>
                
                <div class="tabs">
                    <button class="tab active" data-tab="chart">Visualization</button>
                    <button class="tab" data-tab="stats">Statistics</button>
                    <button class="tab" data-tab="table">Data Table</button>
                    <button class="tab" data-tab="export">Export</button>
                </div>
                
                <div id="chartTab" class="tab-content active">
                    <div class="chart-controls">
                        <div class="chart-select">
                            <label for="chartType">Chart Type</label>
                            <div class="select-wrapper">
                                <select id="chartType">
                                    <option value="bar">Bar Chart</option>
                                    <option value="line">Line Chart</option>
                                    <option value="scatter">Scatter Plot</option>
                                    <option value="histogram">Histogram</option>
                                    <option value="pie">Pie Chart</option>
                                </select>
                                <span class="select-arrow">▼</span>
                            </div>
                        </div>
                        <div class="chart-select">
                            <label for="xAxis">X-Axis</label>
                            <div class="select-wrapper">
                                <select id="xAxis">
                                    <option value="">Select column...</option>
                                </select>
                                <span class="select-arrow">▼</span>
                            </div>
                        </div>
                        <div class="chart-select">
                            <label for="yAxis">Y-Axis</label>
                            <div class="select-wrapper">
                                <select id="yAxis">
                                    <option value="">Select column...</option>
                                </select>
                                <span class="select-arrow">▼</span>
                            </div>
                        </div>
                        <div class="chart-select">
                            <label>&nbsp;</label>
                            <button id="updateChart" class="btn btn-secondary">
                                <span>🔄</span>
                                Update Chart
                            </button>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="chart" style="max-width: 100%; max-height: 400px;"></canvas>
                    </div>
                </div>
                
                <div id="statsTab" class="tab-content">
                    <div id="resultStats" class="result-stats">
                        <div class="stat-card">
                            <div id="rowCount" class="stat-value">-</div>
                            <div class="stat-label">Total Rows</div>
                        </div>
                        <div class="stat-card">
                            <div id="colCount" class="stat-value">-</div>
                            <div class="stat-label">Columns</div>
                        </div>
                        <div class="stat-card">
                            <div id="queryTime" class="stat-value">-</div>
                            <div class="stat-label">Query Time</div>
                        </div>
                        <div class="stat-card">
                            <div id="dataSize" class="stat-value">-</div>
                            <div class="stat-label">Data Size</div>
                        </div>
                    </div>
                    <div id="columnStats" style="margin-top: 24px;"></div>
                </div>
                
                <div id="tableTab" class="tab-content">
                    <div id="resultTable" class="virtual-table"></div>
                </div>
                
                <div id="exportTab" class="tab-content">
                    <div style="text-align: center; padding: 40px;">
                        <h3 style="margin-bottom: 24px;">Export Query Results</h3>
                        <div style="display: flex; gap: 16px; justify-content: center; flex-wrap: wrap;">
                            <button id="exportCSV" class="btn" disabled>
                                <span>📄</span>
                                Export as CSV
                            </button>
                            <button id="exportJSON" class="btn btn-secondary" disabled>
                                <span>📋</span>
                                Export as JSON
                            </button>
                            <button id="copyResults" class="btn btn-secondary" disabled>
                                <span>📋</span>
                                Copy to Clipboard
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Embedded Arrow Data (will be populated by build script) -->
    <script id="arrowData" type="application/octet-stream" data-compressed="true">
        <!-- Base64 encoded compressed Arrow data will be inserted here -->
    </script>

    <script type="module">
        // Import dependencies
        import * as duckdb from 'https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@latest/+esm';
        import * as arrow from 'https://cdn.jsdelivr.net/npm/apache-arrow@latest/+esm';
        import pako from 'https://cdn.jsdelivr.net/npm/pako@2/+esm';
        
        // Global state
        let db = null;
        let conn = null;
        let currentData = null;
        let currentSchema = null;
        let queryWorker = null;
        
        // UI Elements
        const elements = {
            loadingOverlay: document.getElementById('loading-overlay'),
            loadingProgress: document.getElementById('loadingProgress'),
            loadingDetails: document.getElementById('loadingDetails'),
            statusDot: document.getElementById('status-dot'),
            statusText: document.getElementById('status-text'),
            dataInfo: document.getElementById('data-info'),
            sqlEditor: document.getElementById('sqlEditor'),
            runQuery: document.getElementById('runQuery'),
            clearQuery: document.getElementById('clearQuery'),
            presetQueries: document.getElementById('presetQueries'),
            resultTable: document.getElementById('resultTable'),
            rowCount: document.getElementById('rowCount'),
            colCount: document.getElementById('colCount'),
            queryTime: document.getElementById('queryTime'),
            dataSize: document.getElementById('dataSize'),
            chartCanvas: document.getElementById('chart'),
            chartType: document.getElementById('chartType'),
            xAxis: document.getElementById('xAxis'),
            yAxis: document.getElementById('yAxis'),
            updateChart: document.getElementById('updateChart'),
            columnStats: document.getElementById('columnStats'),
            exportCSV: document.getElementById('exportCSV'),
            exportJSON: document.getElementById('exportJSON'),
            copyResults: document.getElementById('copyResults'),
            themeToggle: document.getElementById('themeToggle'),
            themeIcon: document.getElementById('themeIcon')
        };
        
        // Theme management
        function initTheme() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            document.body.setAttribute('data-theme', savedTheme);
            updateThemeIcon(savedTheme);
        }
        
        function toggleTheme() {
            const currentTheme = document.body.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.body.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeIcon(newTheme);
        }
        
        function updateThemeIcon(theme) {
            elements.themeIcon.textContent = theme === 'dark' ? '🌙' : '☀️';
        }
        
        // Update loading progress
        function updateLoadingProgress(percent, details = '') {
            elements.loadingProgress.style.width = percent + '%';
            if (details) {
                elements.loadingDetails.textContent = details;
            }
        }
        
        // Enhanced chart class with more chart types
        class EnhancedChart {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.padding = 60;
                this.isDarkMode = () => document.body.getAttribute('data-theme') === 'dark';
            }
            
            getColors() {
                const isDark = this.isDarkMode();
                return {
                    primary: isDark ? '#3b82f6' : '#2563eb',
                    secondary: isDark ? '#10b981' : '#059669',
                    tertiary: isDark ? '#f59e0b' : '#d97706',
                    text: isDark ? '#f9fafb' : '#111827',
                    textSecondary: isDark ? '#d1d5db' : '#6b7280',
                    grid: isDark ? '#374151' : '#e5e7eb',
                    background: isDark ? '#111827' : '#f3f4f6'
                };
            }
            
            clear() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = 400 * window.devicePixelRatio;
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = '400px';
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            drawPieChart(labels, values) {
                this.clear();
                const colors = this.getColors();
                const centerX = this.canvas.width / (2 * window.devicePixelRatio);
                const centerY = this.canvas.height / (2 * window.devicePixelRatio);
                const radius = Math.min(centerX, centerY) - this.padding;
                
                const total = values.reduce((sum, val) => sum + val, 0);
                let currentAngle = -Math.PI / 2;
                
                const colorPalette = [
                    colors.primary,
                    colors.secondary,
                    colors.tertiary,
                    '#8b5cf6',
                    '#ec4899',
                    '#14b8a6',
                    '#f97316',
                    '#84cc16'
                ];
                
                // Draw slices
                values.forEach((value, i) => {
                    const sliceAngle = (value / total) * 2 * Math.PI;
                    
                    // Draw slice
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                    this.ctx.closePath();
                    this.ctx.fillStyle = colorPalette[i % colorPalette.length];
                    this.ctx.fill();
                    
                    // Draw label
                    const labelAngle = currentAngle + sliceAngle / 2;
                    const labelX = centerX + Math.cos(labelAngle) * (radius * 0.7);
                    const labelY = centerY + Math.sin(labelAngle) * (radius * 0.7);
                    
                    this.ctx.fillStyle = colors.text;
                    this.ctx.font = '12px sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    const percentage = ((value / total) * 100).toFixed(1);
                    this.ctx.fillText(`${labels[i]}`, labelX, labelY - 10);
                    this.ctx.fillText(`${percentage}%`, labelX, labelY + 10);
                    
                    currentAngle += sliceAngle;
                });
            }
            
            drawBarChart(labels, values, xLabel = '', yLabel = '') {
                this.clear();
                const colors = this.getColors();
                const width = this.canvas.width / window.devicePixelRatio - 2 * this.padding;
                const height = this.canvas.height / window.devicePixelRatio - 2 * this.padding;
                
                if (values.length === 0) return;
                
                const maxValue = Math.max(...values);
                const minValue = Math.min(...values, 0);
                const range = maxValue - minValue || 1;
                const barWidth = width / labels.length * 0.8;
                const barGap = width / labels.length * 0.2;
                
                // Draw grid
                this.ctx.strokeStyle = colors.grid;
                this.ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    const y = this.padding + (height * i) / 5;
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.padding, y);
                    this.ctx.lineTo(this.canvas.width / window.devicePixelRatio - this.padding, y);
                    this.ctx.stroke();
                }
                
                // Draw axes
                this.ctx.strokeStyle = colors.text;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(this.padding, this.padding);
                this.ctx.lineTo(this.padding, this.canvas.height / window.devicePixelRatio - this.padding);
                this.ctx.lineTo(this.canvas.width / window.devicePixelRatio - this.padding, this.canvas.height / window.devicePixelRatio - this.padding);
                this.ctx.stroke();
                
                // Draw bars
                this.ctx.fillStyle = colors.primary;
                values.forEach((value, i) => {
                    const barHeight = ((value - minValue) / range) * height;
                    const x = this.padding + i * (barWidth + barGap) + barGap / 2;
                    const y = this.canvas.height / window.devicePixelRatio - this.padding - barHeight;
                    
                    this.ctx.fillRect(x, y, barWidth, barHeight);
                    
                    // Draw value label
                    this.ctx.fillStyle = colors.textSecondary;
                    this.ctx.font = '12px sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(
                        value.toLocaleString(), 
                        x + barWidth / 2, 
                        y - 5
                    );
                    
                    // Draw x-axis label
                    this.ctx.save();
                    this.ctx.translate(x + barWidth / 2, this.canvas.height / window.devicePixelRatio - this.padding + 15);
                    this.ctx.rotate(-Math.PI / 4);
                    this.ctx.textAlign = 'right';
                    this.ctx.fillText(String(labels[i]).substring(0, 20), 0, 0);
                    this.ctx.restore();
                    
                    this.ctx.fillStyle = colors.primary;
                });
                
                this.drawAxisLabels(xLabel, yLabel);
            }
            
            drawLineChart(xValues, yValues, xLabel = '', yLabel = '') {
                this.clear();
                const colors = this.getColors();
                const width = this.canvas.width / window.devicePixelRatio - 2 * this.padding;
                const height = this.canvas.height / window.devicePixelRatio - 2 * this.padding;
                
                if (xValues.length === 0) return;
                
                const xMin = Math.min(...xValues);
                const xMax = Math.max(...xValues);
                const yMin = Math.min(...yValues);
                const yMax = Math.max(...yValues);
                const xRange = xMax - xMin || 1;
                const yRange = yMax - yMin || 1;
                
                // Draw grid
                this.ctx.strokeStyle = colors.grid;
                this.ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    const y = this.padding + (height * i) / 5;
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.padding, y);
                    this.ctx.lineTo(this.canvas.width / window.devicePixelRatio - this.padding, y);
                    this.ctx.stroke();
                }
                
                // Draw axes
                this.ctx.strokeStyle = colors.text;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(this.padding, this.padding);
                this.ctx.lineTo(this.padding, this.canvas.height / window.devicePixelRatio - this.padding);
                this.ctx.lineTo(this.canvas.width / window.devicePixelRatio - this.padding, this.canvas.height / window.devicePixelRatio - this.padding);
                this.ctx.stroke();
                
                // Draw line
                this.ctx.strokeStyle = colors.primary;
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                
                xValues.forEach((x, i) => {
                    const xPos = this.padding + ((x - xMin) / xRange) * width;
                    const yPos = this.canvas.height / window.devicePixelRatio - this.padding - ((yValues[i] - yMin) / yRange) * height;
                    
                    if (i === 0) {
                        this.ctx.moveTo(xPos, yPos);
                    } else {
                        this.ctx.lineTo(xPos, yPos);
                    }
                });
                
                this.ctx.stroke();
                
                // Draw points
                this.ctx.fillStyle = colors.primary;
                xValues.forEach((x, i) => {
                    const xPos = this.padding + ((x - xMin) / xRange) * width;
                    const yPos = this.canvas.height / window.devicePixelRatio - this.padding - ((yValues[i] - yMin) / yRange) * height;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(xPos, yPos, 4, 0, 2 * Math.PI);
                    this.ctx.fill();
                });
                
                this.drawAxisLabels(xLabel, yLabel);
            }
            
            drawScatterPlot(xValues, yValues, xLabel = '', yLabel = '') {
                this.clear();
                const colors = this.getColors();
                const width = this.canvas.width / window.devicePixelRatio - 2 * this.padding;
                const height = this.canvas.height / window.devicePixelRatio - 2 * this.padding;
                
                if (xValues.length === 0) return;
                
                const xMin = Math.min(...xValues);
                const xMax = Math.max(...xValues);
                const yMin = Math.min(...yValues);
                const yMax = Math.max(...yValues);
                const xRange = xMax - xMin || 1;
                const yRange = yMax - yMin || 1;
                
                // Draw grid
                this.ctx.strokeStyle = colors.grid;
                this.ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    const y = this.padding + (height * i) / 5;
                    const x = this.padding + (width * i) / 5;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.padding, y);
                    this.ctx.lineTo(this.canvas.width / window.devicePixelRatio - this.padding, y);
                    this.ctx.stroke();
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, this.padding);
                    this.ctx.lineTo(x, this.canvas.height / window.devicePixelRatio - this.padding);
                    this.ctx.stroke();
                }
                
                // Draw axes
                this.ctx.strokeStyle = colors.text;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(this.padding, this.padding);
                this.ctx.lineTo(this.padding, this.canvas.height / window.devicePixelRatio - this.padding);
                this.ctx.lineTo(this.canvas.width / window.devicePixelRatio - this.padding, this.canvas.height / window.devicePixelRatio - this.padding);
                this.ctx.stroke();
                
                // Draw points
                this.ctx.fillStyle = colors.primary + '99'; // Add transparency
                xValues.forEach((x, i) => {
                    const xPos = this.padding + ((x - xMin) / xRange) * width;
                    const yPos = this.canvas.height / window.devicePixelRatio - this.padding - ((yValues[i] - yMin) / yRange) * height;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(xPos, yPos, 6, 0, 2 * Math.PI);
                    this.ctx.fill();
                });
                
                this.drawAxisLabels(xLabel, yLabel);
            }
            
            drawHistogram(values, bins = 20, label = '') {
                this.clear();
                
                if (values.length === 0) return;
                
                const min = Math.min(...values);
                const max = Math.max(...values);
                const binWidth = (max - min) / bins;
                
                // Create bins
                const histogram = new Array(bins).fill(0);
                values.forEach(value => {
                    const binIndex = Math.min(Math.floor((value - min) / binWidth), bins - 1);
                    histogram[binIndex]++;
                });
                
                // Create labels
                const labels = histogram.map((_, i) => {
                    const start = min + i * binWidth;
                    return start.toFixed(2);
                });
                
                this.drawBarChart(labels, histogram, label, 'Frequency');
            }
            
            drawAxisLabels(xLabel, yLabel) {
                const colors = this.getColors();
                this.ctx.fillStyle = colors.text;
                this.ctx.font = '14px sans-serif';
                this.ctx.textAlign = 'center';
                
                // X-axis label
                if (xLabel) {
                    this.ctx.fillText(
                        xLabel,
                        this.canvas.width / (2 * window.devicePixelRatio),
                        this.canvas.height / window.devicePixelRatio - 10
                    );
                }
                
                // Y-axis label
                if (yLabel) {
                    this.ctx.save();
                    this.ctx.translate(15, this.canvas.height / (2 * window.devicePixelRatio));
                    this.ctx.rotate(-Math.PI / 2);
                    this.ctx.fillText(yLabel, 0, 0);
                    this.ctx.restore();
                }
            }
        }
        
        // Virtual table implementation for better performance
        class VirtualTable {
            constructor(container, data, schema) {
                this.container = container;
                this.data = data;
                this.schema = schema;
                this.rowHeight = 48;
                this.visibleRows = 20;
                this.scrollTop = 0;
                this.render();
            }
            
            render() {
                const columns = this.schema.fields.map(field => field.name);
                const totalHeight = this.data.length * this.rowHeight;
                
                // Create header
                const header = document.createElement('div');
                header.className = 'virtual-table-header';
                header.innerHTML = `
                    <div class="virtual-table-row">
                        ${columns.map(col => `<div class="virtual-table-cell">${this.escapeHtml(col)}</div>`).join('')}
                    </div>
                `;
                
                // Create scrollable body
                const body = document.createElement('div');
                body.className = 'virtual-table-body';
                body.style.height = `${this.visibleRows * this.rowHeight}px`;
                
                // Create viewport
                const viewport = document.createElement('div');
                viewport.className = 'virtual-table-viewport';
                viewport.style.height = `${totalHeight}px`;
                
                body.appendChild(viewport);
                
                // Handle scroll
                body.addEventListener('scroll', () => {
                    this.scrollTop = body.scrollTop;
                    this.updateVisibleRows(viewport, columns);
                });
                
                // Initial render
                this.updateVisibleRows(viewport, columns);
                
                // Clear container and add elements
                this.container.innerHTML = '';
                this.container.appendChild(header);
                this.container.appendChild(body);
            }
            
            updateVisibleRows(viewport, columns) {
                const startIndex = Math.floor(this.scrollTop / this.rowHeight);
                const endIndex = Math.min(startIndex + this.visibleRows + 1, this.data.length);
                
                let html = '';
                for (let i = startIndex; i < endIndex; i++) {
                    const row = this.data[i];
                    const top = i * this.rowHeight;
                    html += `
                        <div class="virtual-table-row" style="position: absolute; top: ${top}px; width: 100%;">
                            ${columns.map(col => {
                                const value = row[col];
                                const displayValue = value === null ? '<span style="color: var(--text-tertiary); font-style: italic;">NULL</span>' : 
                                                   value instanceof Date ? value.toISOString().split('T')[0] :
                                                   this.escapeHtml(String(value));
                                return `<div class="virtual-table-cell">${displayValue}</div>`;
                            }).join('')}
                        </div>
                    `;
                }
                
                viewport.innerHTML = html;
            }
            
            escapeHtml(unsafe) {
                return unsafe
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }
        }
        
        const chart = new EnhancedChart(elements.chartCanvas);
        
        // Tab functionality
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                
                // Update active tab
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Show corresponding content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(tabName + 'Tab').classList.add('active');
                
                // Redraw chart if switching to chart tab
                if (tabName === 'chart' && currentData) {
                    updateChart();
                }
            });
        });
        
        // Update status
        function updateStatus(message, type = 'loading') {
            elements.statusText.textContent = message;
            elements.statusDot.className = 'status-dot ' + (type === 'ready' ? 'ready' : type === 'error' ? 'error' : '');
        }
        
        // Format bytes to human readable
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // Load Arrow data from embedded base64
        async function loadArrowData() {
            try {
                updateStatus('Loading Arrow data...', 'loading');
                updateLoadingProgress(30, 'Decoding Arrow data...');
                
                // Get the embedded Arrow data
                const arrowDataElement = document.getElementById('arrowData');
                let arrowData = arrowDataElement.textContent.trim();
                const isCompressed = arrowDataElement.dataset.compressed === 'true';
                
                // For development: if no data is embedded, create sample data
                if (!arrowData || arrowData.includes('Base64 encoded')) {
                    console.log('No embedded data found, creating sample data...');
                    updateLoadingProgress(100, 'Creating sample data...');
                    return await createSampleData();
                }
                
                updateLoadingProgress(40, 'Processing data...');
                
                // Decode base64 to binary
                const binaryString = atob(arrowData);
                const compressedBytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    compressedBytes[i] = binaryString.charCodeAt(i);
                }
                
                updateLoadingProgress(50, 'Decompressing data...');
                
                let bytes;
                if (isCompressed) {
                    // Decompress the data
                    bytes = pako.ungzip(compressedBytes);
                    updateLoadingProgress(70, 'Decompression complete');
                } else {
                    bytes = compressedBytes;
                }
                
                // Read Arrow data
                updateLoadingProgress(80, 'Reading Arrow format...');
                const reader = arrow.RecordBatchReader.from(bytes);
                const table = new arrow.Table(reader);
                
                // Convert to DuckDB
                updateLoadingProgress(90, 'Loading into DuckDB...');
                await conn.insertArrowTable(table, { name: 'arrow_data' });
                
                // Get table info
                const countResult = await conn.query('SELECT COUNT(*) as count FROM arrow_data');
                const count = countResult.toArray()[0].count;
                
                elements.dataInfo.textContent = `${count.toLocaleString()} rows`;
                elements.dataSize.textContent = formatBytes(bytes.length);
                updateStatus('Data loaded successfully', 'ready');
                updateLoadingProgress(100, 'Ready!');
                
                return true;
            } catch (error) {
                console.error('Error loading Arrow data:', error);
                updateStatus(`Error loading data: ${error.message}`, 'error');
                return false;
            }
        }
        
        // Create sample data for development
        async function createSampleData() {
            try {
                // Create a sample table with various data types
                await conn.query(`
                    CREATE TABLE arrow_data AS 
                    SELECT 
                        row_number() OVER () AS id,
                        'Product_' || (row_number() OVER ()) AS product_name,
                        ROUND((random() * 1000)::DECIMAL, 2) AS price,
                        CAST((random() * 100)::INT AS INT) AS quantity,
                        CASE 
                            WHEN random() < 0.25 THEN 'Electronics'
                            WHEN random() < 0.5 THEN 'Clothing'
                            WHEN random() < 0.75 THEN 'Food'
                            ELSE 'Other'
                        END AS category,
                        DATE '2024-01-01' + INTERVAL (random() * 365) DAY AS sale_date,
                        random() > 0.5 AS is_featured,
                        ROUND((random() * 5)::DECIMAL, 1) AS rating,
                        'Description for product ' || (row_number() OVER ()) AS description
                    FROM generate_series(1, 10000)
                `);
                
                elements.dataInfo.textContent = '10,000 rows (sample)';
                elements.dataSize.textContent = 'Sample Data';
                updateStatus('Sample data created', 'ready');
                return true;
            } catch (error) {
                console.error('Error creating sample data:', error);
                updateStatus(`Error creating sample data: ${error.message}`, 'error');
                return false;
            }
        }
        
        // Initialize DuckDB with Web Worker support
        async function initializeDuckDB() {
            try {
                updateLoadingProgress(10, 'Initializing DuckDB engine...');
                
                // Initialize DuckDB-WASM
                const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();
                const bundle = await duckdb.selectBundle(JSDELIVR_BUNDLES);
                
                updateLoadingProgress(20, 'Setting up database...');
                
                const worker_url = URL.createObjectURL(
                    new Blob([`importScripts("${bundle.mainWorker}");`], {type: 'text/javascript'})
                );
                
                const worker = new Worker(worker_url);
                const logger = new duckdb.ConsoleLogger();
                db = new duckdb.AsyncDuckDB(logger, worker);
                
                await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
                URL.revokeObjectURL(worker_url);
                
                conn = await db.connect();
                
                // Load Arrow data
                const dataLoaded = await loadArrowData();
                
                if (dataLoaded) {
                    // Enable controls
                    elements.runQuery.disabled = false;
                    elements.clearQuery.disabled = false;
                    elements.presetQueries.disabled = false;
                    elements.exportCSV.disabled = false;
                    elements.exportJSON.disabled = false;
                    elements.copyResults.disabled = false;
                    
                    // Fade out loading overlay
                    setTimeout(() => {
                        elements.loadingOverlay.classList.add('fade-out');
                        setTimeout(() => {
                            elements.loadingOverlay.style.display = 'none';
                        }, 300);
                    }, 500);
                    
                    // Run initial query after a short delay
                    setTimeout(() => {
                        runQuery();
                    }, 1000);
                }
            } catch (error) {
                updateStatus(`Initialization error: ${error.message}`, 'error');
                console.error('DuckDB initialization error:', error);
                elements.loadingOverlay.style.display = 'none';
                
                // Show error in results
                document.getElementById('tableTab').innerHTML = `
                    <div class="error-message">
                        <span>⚠</span>
                        <span>Failed to initialize: ${error.message}</span>
                    </div>
                `;
            }
        }
        
        // Run SQL query with performance tracking
        async function runQuery() {
            const sql = elements.sqlEditor.value.trim();
            if (!sql) return;
            
            try {
                updateStatus('Running query...', 'loading');
                const startTime = performance.now();
                
                const result = await conn.query(sql);
                const data = result.toArray();
                const schema = result.schema;
                
                const duration = performance.now() - startTime;
                
                currentData = data;
                currentSchema = schema;
                
                updateStatus('Query completed', 'ready');
                
                // Update stats
                elements.rowCount.textContent = data.length.toLocaleString();
                elements.colCount.textContent = schema.fields.length.toLocaleString();
                elements.queryTime.textContent = `${duration.toFixed(2)}ms`;
                
                // Display results
                displayResults(data, schema);
                updateChartOptions(schema);
                displayColumnStats(data, schema);
                
                // Auto-update chart if on chart tab
                const activeTab = document.querySelector('.tab.active');
                if (activeTab && activeTab.dataset.tab === 'chart') {
                    updateChart();
                }
                
            } catch (error) {
                updateStatus(`Query error: ${error.message}`, 'error');
                console.error('Query error:', error);
                
                document.getElementById('tableTab').innerHTML = `
                    <div class="error-message">
                        <span>⚠</span>
                        <span>${error.message}</span>
                    </div>
                `;
            }
        }
        
        // Display query results using virtual table
        function displayResults(data, schema) {
            if (!data || data.length === 0) {
                elements.resultTable.innerHTML = '<p style="padding: 20px; text-align: center; color: var(--text-secondary);">No results returned</p>';
                return;
            }
            
            // Use virtual table for better performance
            new VirtualTable(elements.resultTable, data, schema);
        }
        
        // Display column statistics
        function displayColumnStats(data, schema) {
            if (!data || data.length === 0) {
                elements.columnStats.innerHTML = '';
                return;
            }
            
            let html = '<h3 style="margin-bottom: 16px;">Column Statistics</h3>';
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 16px;">';
            
            schema.fields.forEach(field => {
                const columnData = data.map(row => row[field.name]);
                const stats = calculateColumnStats(columnData, field.type);
                
                html += `
                    <div class="stat-card">
                        <h4 style="font-size: 16px; margin-bottom: 8px; color: var(--primary-color);">${field.name}</h4>
                        <div style="font-size: 14px; color: var(--text-secondary);">
                            <div>Type: <span class="type-badge">${field.type}</span></div>
                            ${stats}
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            elements.columnStats.innerHTML = html;
        }
        
        // Calculate statistics for a column
        function calculateColumnStats(values, type) {
            const nonNullValues = values.filter(v => v !== null);
            const nullCount = values.length - nonNullValues.length;
            
            let stats = `<div>Non-null: ${nonNullValues.length.toLocaleString()}</div>`;
            stats += `<div>Null: ${nullCount.toLocaleString()}</div>`;
            
            if (nonNullValues.length === 0) return stats;
            
            // Numeric statistics
            if (type.toString().includes('Int') || type.toString().includes('Float') || type.toString().includes('Decimal')) {
                const numbers = nonNullValues.map(Number).filter(n => !isNaN(n));
                if (numbers.length > 0) {
                    const min = Math.min(...numbers);
                    const max = Math.max(...numbers);
                    const sum = numbers.reduce((a, b) => a + b, 0);
                    const avg = sum / numbers.length;
                    
                    stats += `<div>Min: ${min.toLocaleString()}</div>`;
                    stats += `<div>Max: ${max.toLocaleString()}</div>`;
                    stats += `<div>Avg: ${avg.toFixed(2)}</div>`;
                }
            }
            
            // String statistics
            if (type.toString().includes('Utf8') || type.toString().includes('String')) {
                const uniqueValues = new Set(nonNullValues);
                stats += `<div>Unique: ${uniqueValues.size.toLocaleString()}</div>`;
            }
            
            return stats;
        }
        
        // Update chart options based on schema
        function updateChartOptions(schema) {
            // Clear existing options
            elements.xAxis.innerHTML = '<option value="">Select column...</option>';
            elements.yAxis.innerHTML = '<option value="">Select column...</option>';
            
            // Add columns as options
            schema.fields.forEach(field => {
                const option = `<option value="${field.name}">${field.name}</option>`;
                elements.xAxis.innerHTML += option;
                elements.yAxis.innerHTML += option;
            });
        }
        
        // Update chart with current data
        function updateChart() {
            if (!currentData || currentData.length === 0) return;
            
            const chartType = elements.chartType.value;
            const xCol = elements.xAxis.value;
            const yCol = elements.yAxis.value;
            
            if (!xCol && chartType !== 'histogram') {
                chart.clear();
                return;
            }
            
            try {
                switch (chartType) {
                    case 'bar':
                        if (!xCol || !yCol) return;
                        const labels = currentData.slice(0, 50).map(row => row[xCol]);
                        const values = currentData.slice(0, 50).map(row => Number(row[yCol]) || 0);
                        chart.drawBarChart(labels, values, xCol, yCol);
                        break;
                        
                    case 'line':
                        if (!xCol || !yCol) return;
                        const xValues = currentData.map(row => Number(row[xCol]) || 0);
                        const yValues = currentData.map(row => Number(row[yCol]) || 0);
                        chart.drawLineChart(xValues, yValues, xCol, yCol);
                        break;
                        
                    case 'scatter':
                        if (!xCol || !yCol) return;
                        const scatterX = currentData.map(row => Number(row[xCol]) || 0);
                        const scatterY = currentData.map(row => Number(row[yCol]) || 0);
                        chart.drawScatterPlot(scatterX, scatterY, xCol, yCol);
                        break;
                        
                    case 'histogram':
                        if (!xCol) return;
                        const histValues = currentData.map(row => Number(row[xCol]) || 0);
                        chart.drawHistogram(histValues, 20, xCol);
                        break;
                        
                    case 'pie':
                        if (!xCol || !yCol) return;
                        // Aggregate data for pie chart
                        const aggregated = {};
                        currentData.forEach(row => {
                            const key = row[xCol];
                            const value = Number(row[yCol]) || 0;
                            aggregated[key] = (aggregated[key] || 0) + value;
                        });
                        
                        const pieLabels = Object.keys(aggregated).slice(0, 8);
                        const pieValues = pieLabels.map(key => aggregated[key]);
                        chart.drawPieChart(pieLabels, pieValues);
                        break;
                }
            } catch (error) {
                console.error('Chart error:', error);
                chart.clear();
            }
        }
        
        // Export functions
        function exportToCSV() {
            if (!currentData || currentData.length === 0) return;
            
            const columns = currentSchema.fields.map(field => field.name);
            let csv = columns.map(col => `"${col}"`).join(',') + '\n';
            
            currentData.forEach(row => {
                const values = columns.map(col => {
                    const value = row[col];
                    if (value === null) return '';
                    if (typeof value === 'string') return `"${value.replace(/"/g, '""')}"`;
                    return String(value);
                });
                csv += values.join(',') + '\n';
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `query_results_${new Date().toISOString().slice(0, 10)}.csv`;
            a.click();
            URL.revokeObjectURL(url);
            
            // Show success message
            const exportTab = document.getElementById('exportTab');
            const successMsg = document.createElement('div');
            successMsg.className = 'success-message';
            successMsg.innerHTML = '<span>✓</span><span>CSV exported successfully!</span>';
            exportTab.insertBefore(successMsg, exportTab.firstChild);
            setTimeout(() => successMsg.remove(), 3000);
        }
        
        function exportToJSON() {
            if (!currentData || currentData.length === 0) return;
            
            const json = JSON.stringify(currentData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `query_results_${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            // Show success message
            const exportTab = document.getElementById('exportTab');
            const successMsg = document.createElement('div');
            successMsg.className = 'success-message';
            successMsg.innerHTML = '<span>✓</span><span>JSON exported successfully!</span>';
            exportTab.insertBefore(successMsg, exportTab.firstChild);
            setTimeout(() => successMsg.remove(), 3000);
        }
        
        async function copyToClipboard() {
            if (!currentData || currentData.length === 0) return;
            
            const columns = currentSchema.fields.map(field => field.name);
            let text = columns.join('\t') + '\n';
            
            currentData.slice(0, 1000).forEach(row => {
                const values = columns.map(col => {
                    const value = row[col];
                    return value === null ? '' : String(value);
                });
                text += values.join('\t') + '\n';
            });
            
            try {
                await navigator.clipboard.writeText(text);
                
                // Show success message
                const exportTab = document.getElementById('exportTab');
                const successMsg = document.createElement('div');
                successMsg.className = 'success-message';
                successMsg.innerHTML = '<span>✓</span><span>Data copied to clipboard!</span>';
                exportTab.insertBefore(successMsg, exportTab.firstChild);
                setTimeout(() => successMsg.remove(), 3000);
            } catch (error) {
                console.error('Failed to copy:', error);
            }
        }
        
        // Event listeners
        elements.themeToggle.addEventListener('click', toggleTheme);
        elements.runQuery.addEventListener('click', runQuery);
        
        elements.clearQuery.addEventListener('click', () => {
            elements.sqlEditor.value = '';
            elements.sqlEditor.focus();
        });
        
        elements.presetQueries.addEventListener('change', (e) => {
            if (e.target.value) {
                elements.sqlEditor.value = e.target.value;
                runQuery();
            }
        });
        
        elements.sqlEditor.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                runQuery();
            }
        });
        
        elements.exportCSV.addEventListener('click', exportToCSV);
        elements.exportJSON.addEventListener('click', exportToJSON);
        elements.copyResults.addEventListener('click', copyToClipboard);
        elements.updateChart.addEventListener('click', updateChart);
        
        // Auto-update chart when selections change
        elements.chartType.addEventListener('change', updateChart);
        elements.xAxis.addEventListener('change', updateChart);
        elements.yAxis.addEventListener('change', updateChart);
        
        // Initialize theme and start the application
        initTheme();
        
        // Use requestIdleCallback for non-critical initialization
        if ('requestIdleCallback' in window) {
            requestIdleCallback(() => {
                initializeDuckDB();
            });
        } else {
            setTimeout(initializeDuckDB, 100);
        }
    </script>
</body>
</html>