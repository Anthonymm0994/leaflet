<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Data Visualization - 1M Rows</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f0f;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        
        #app {
            display: none;
            height: 100vh;
            padding: 10px;
        }
        
        .header {
            background: #1a1a1a;
            padding: 10px 20px;
            margin-bottom: 10px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stats {
            display: flex;
            gap: 20px;
        }
        
        .controls {
            display: flex;
            gap: 10px;
        }
        
        button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #1d4ed8;
        }
        
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 10px;
            height: calc(100vh - 100px);
        }
        
        .chart-container {
            background: #1a1a1a;
            border-radius: 4px;
            padding: 10px;
            position: relative;
        }
        
        .chart-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        canvas {
            cursor: crosshair;
            display: block;
        }
        
        #tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            border: 1px solid #333;
        }
        
        select {
            background: #2a2a2a;
            color: white;
            border: 1px solid #444;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-left: 10px;
        }
        
        .progress {
            width: 300px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
            margin: 20px auto;
        }
        
        .progress-bar {
            height: 100%;
            background: #2563eb;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="loading">
        <h2>Generating 1,000,000 records...</h2>
        <div class="progress">
            <div class="progress-bar" id="progressBar" style="width: 0%"></div>
        </div>
        <div id="loadingText">0%</div>
    </div>
    
    <div id="app">
        <div class="header">
            <h1>Data Explorer</h1>
            <div class="stats">
                <span>Total: <strong>1,000,000</strong></span>
                <span>Filtered: <strong id="filteredCount">1,000,000</strong></span>
                <span>Selected: <strong id="selectedPercent">100%</strong></span>
            </div>
            <div class="controls">
                <button onclick="resetAllFilters()">Reset All</button>
                <button onclick="exportCSV()">Export CSV</button>
            </div>
        </div>
        
        <div class="chart-grid">
            <div class="chart-container">
                <div class="chart-title">Width Distribution</div>
                <canvas id="widthChart"></canvas>
            </div>
            
            <div class="chart-container">
                <div class="chart-title">Height Distribution</div>
                <canvas id="heightChart"></canvas>
            </div>
            
            <div class="chart-container">
                <div class="chart-title">
                    Angle Distribution
                    <select id="angleMode" onchange="updateAngleChart()">
                        <option value="category_2">Category 2 (T/F)</option>
                        <option value="category_4">Category 4 (A/B/C/D)</option>
                    </select>
                </div>
                <canvas id="angleChart"></canvas>
            </div>
            
            <div class="chart-container">
                <div class="chart-title">Time Distribution (24h)</div>
                <canvas id="timeChart"></canvas>
            </div>
            
            <div class="chart-container">
                <div class="chart-title">Strength Distribution</div>
                <canvas id="strengthChart"></canvas>
            </div>
            
            <div class="chart-container">
                <div class="chart-title">Category Distribution</div>
                <canvas id="categoryChart"></canvas>
            </div>
        </div>
    </div>
    
    <div id="tooltip"></div>
    
    <script>
        // Constants
        const ROWS = 1000000;
        const BINS = 50;
        const TIME_BINS = 48; // 30-minute intervals
        const ANGLE_SEGMENTS = 72; // 5-degree segments
        
        // Data storage
        let data = {
            time: new Float32Array(ROWS),
            width: new Float32Array(ROWS),
            height: new Float32Array(ROWS),
            angle: new Float32Array(ROWS),
            strength: new Float32Array(ROWS),
            category_4: new Uint8Array(ROWS),
            category_2: new Uint8Array(ROWS)
        };
        
        // Filter state
        let filters = {
            width: null,
            height: null,
            angle: null,
            time: null,
            strength: null,
            category: new Set(['A', 'B', 'C', 'D'])
        };
        
        let filteredMask = new Uint8Array(ROWS);
        let filteredCount = ROWS;
        
        // Chart contexts
        let charts = {};
        
        // Color schemes
        const colors = {
            A: '#ff6384',
            B: '#36a2eb',  
            C: '#ffce56',
            D: '#4bc0c0',
            true: '#66d9ef',
            false: '#f92672'
        };
        
        // Generate synthetic data
        function generateData() {
            const batchSize = 50000;
            let processed = 0;
            
            function processBatch() {
                const end = Math.min(processed + batchSize, ROWS);
                
                for (let i = processed; i < end; i++) {
                    // Time: seconds since midnight
                    data.time[i] = Math.random() * 86400;
                    
                    // Width: 1.00 - 200.00
                    data.width[i] = Math.random() * 199 + 1;
                    
                    // Height: 0.20 - 4.80
                    data.height[i] = Math.random() * 4.6 + 0.2;
                    
                    // Angle: 0 - 360
                    data.angle[i] = Math.random() * 360;
                    
                    // Strength: exponential distribution
                    data.strength[i] = -Math.log(Math.random()) * 50;
                    
                    // Category 4: 0-3 (A-D)
                    data.category_4[i] = Math.floor(Math.random() * 4);
                    
                    // Category 2: 0-1 (false/true)
                    data.category_2[i] = Math.random() < 0.5 ? 1 : 0;
                    
                    // Initially all data is included
                    filteredMask[i] = 1;
                }
                
                processed = end;
                const progress = (processed / ROWS) * 100;
                document.getElementById('progressBar').style.width = progress + '%';
                document.getElementById('loadingText').textContent = Math.floor(progress) + '%';
                
                if (processed < ROWS) {
                    requestAnimationFrame(processBatch);
                } else {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('app').style.display = 'block';
                    initCharts();
                    updateAllCharts();
                }
            }
            
            processBatch();
        }
        
        // Initialize all charts
        function initCharts() {
            initHistogram('widthChart', 'width', [1, 200], 'Width');
            initHistogram('heightChart', 'height', [0.2, 4.8], 'Height');
            initRadialChart('angleChart');
            initTimeChart('timeChart');
            initHistogram('strengthChart', 'strength', [0, 200], 'Strength');
            initCategoryChart('categoryChart');
        }
        
        // Histogram chart implementation
        function initHistogram(canvasId, dataKey, range, label) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = (rect.width - 20) * dpr;
            canvas.height = (rect.height - 40) * dpr;
            canvas.style.width = (rect.width - 20) + 'px';
            canvas.style.height = (rect.height - 40) + 'px';
            ctx.scale(dpr, dpr);
            
            const width = rect.width - 20;
            const height = rect.height - 40;
            const margin = { top: 20, right: 20, bottom: 30, left: 40 };
            
            charts[canvasId] = {
                ctx,
                width,
                height,
                margin,
                dataKey,
                range,
                label,
                draw: () => drawHistogram(canvasId),
                selection: null,
                isDragging: false
            };
            
            // Mouse events
            let startX = null;
            
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                startX = e.clientX - rect.left;
                charts[canvasId].isDragging = true;
                charts[canvasId].selection = [startX, startX];
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (charts[canvasId].isDragging && startX !== null) {
                    charts[canvasId].selection = [Math.min(startX, x), Math.max(startX, x)];
                    drawHistogram(canvasId);
                }
                
                // Tooltip
                showTooltip(e, getHistogramTooltip(canvasId, x, y));
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (charts[canvasId].isDragging && charts[canvasId].selection) {
                    const chart = charts[canvasId];
                    const chartWidth = chart.width - chart.margin.left - chart.margin.right;
                    const [x1, x2] = chart.selection;
                    
                    const start = chart.range[0] + (x1 - chart.margin.left) / chartWidth * (chart.range[1] - chart.range[0]);
                    const end = chart.range[0] + (x2 - chart.margin.left) / chartWidth * (chart.range[1] - chart.range[0]);
                    
                    filters[dataKey] = [Math.max(start, chart.range[0]), Math.min(end, chart.range[1])];
                    applyFilters();
                }
                
                charts[canvasId].isDragging = false;
                startX = null;
            });
            
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                
                if (x < margin.left || x > width - margin.right) {
                    filters[dataKey] = null;
                    charts[canvasId].selection = null;
                    applyFilters();
                }
            });
            
            canvas.addEventListener('mouseleave', () => {
                hideTooltip();
            });
        }
        
        // Draw histogram
        function drawHistogram(canvasId) {
            const chart = charts[canvasId];
            const { ctx, width, height, margin, dataKey, range } = chart;
            
            ctx.clearRect(0, 0, width, height);
            
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            // Compute histogram
            const bins = new Array(BINS).fill(0);
            const filteredBins = new Array(BINS).fill(0);
            const binSize = (range[1] - range[0]) / BINS;
            
            for (let i = 0; i < ROWS; i++) {
                const value = data[dataKey][i];
                const binIndex = Math.floor((value - range[0]) / binSize);
                if (binIndex >= 0 && binIndex < BINS) {
                    bins[binIndex]++;
                    if (filteredMask[i]) {
                        filteredBins[binIndex]++;
                    }
                }
            }
            
            const maxCount = Math.max(...bins);
            const barWidth = chartWidth / BINS;
            
            // Draw background bars
            ctx.fillStyle = '#333';
            for (let i = 0; i < BINS; i++) {
                const barHeight = (bins[i] / maxCount) * chartHeight;
                ctx.fillRect(
                    margin.left + i * barWidth,
                    margin.top + chartHeight - barHeight,
                    barWidth - 1,
                    barHeight
                );
            }
            
            // Draw filtered bars
            ctx.fillStyle = '#2563eb';
            for (let i = 0; i < BINS; i++) {
                const barHeight = (filteredBins[i] / maxCount) * chartHeight;
                ctx.fillRect(
                    margin.left + i * barWidth,
                    margin.top + chartHeight - barHeight,
                    barWidth - 1,
                    barHeight
                );
            }
            
            // Draw selection
            if (chart.selection) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(
                    chart.selection[0],
                    margin.top,
                    chart.selection[1] - chart.selection[0],
                    chartHeight
                );
            }
            
            // Draw axes
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top + chartHeight);
            ctx.lineTo(margin.left + chartWidth, margin.top + chartHeight);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#999';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';
            
            for (let i = 0; i <= 5; i++) {
                const x = margin.left + (i / 5) * chartWidth;
                const value = range[0] + (i / 5) * (range[1] - range[0]);
                ctx.fillText(value.toFixed(1), x, height - 10);
            }
        }
        
        // Radial chart implementation
        function initRadialChart(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const size = Math.min(rect.width - 20, rect.height - 40);
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            ctx.scale(dpr, dpr);
            
            charts[canvasId] = {
                ctx,
                size,
                draw: () => drawRadialChart(canvasId),
                selection: null,
                isDragging: false
            };
            
            // Mouse events
            let startAngle = null;
            
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left - size/2;
                const y = e.clientY - rect.top - size/2;
                startAngle = Math.atan2(y, x) * 180 / Math.PI + 90;
                if (startAngle < 0) startAngle += 360;
                charts[canvasId].isDragging = true;
                charts[canvasId].selection = [startAngle, startAngle];
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left - size/2;
                const y = e.clientY - rect.top - size/2;
                
                if (charts[canvasId].isDragging && startAngle !== null) {
                    let endAngle = Math.atan2(y, x) * 180 / Math.PI + 90;
                    if (endAngle < 0) endAngle += 360;
                    
                    // Handle wrap-around
                    if (Math.abs(endAngle - startAngle) > 180) {
                        if (startAngle < endAngle) {
                            charts[canvasId].selection = [0, endAngle].concat([startAngle, 360]);
                        } else {
                            charts[canvasId].selection = [0, startAngle].concat([endAngle, 360]);
                        }
                    } else {
                        charts[canvasId].selection = [Math.min(startAngle, endAngle), Math.max(startAngle, endAngle)];
                    }
                    
                    drawRadialChart(canvasId);
                }
                
                // Tooltip
                const angle = Math.atan2(y, x) * 180 / Math.PI + 90;
                const normalizedAngle = angle < 0 ? angle + 360 : angle;
                showTooltip(e, `Angle: ${normalizedAngle.toFixed(1)}°`);
            });
            
            canvas.addEventListener('mouseup', () => {
                if (charts[canvasId].isDragging && charts[canvasId].selection) {
                    filters.angle = charts[canvasId].selection;
                    applyFilters();
                }
                charts[canvasId].isDragging = false;
                startAngle = null;
            });
            
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left - size/2;
                const y = e.clientY - rect.top - size/2;
                const distance = Math.sqrt(x*x + y*y);
                
                if (distance > size/2 - 10) {
                    filters.angle = null;
                    charts[canvasId].selection = null;
                    applyFilters();
                }
            });
            
            canvas.addEventListener('mouseleave', () => {
                hideTooltip();
            });
        }
        
        // Draw radial chart
        function drawRadialChart(canvasId) {
            const chart = charts[canvasId];
            const { ctx, size } = chart;
            const mode = document.getElementById('angleMode').value;
            
            ctx.clearRect(0, 0, size, size);
            
            const center = size / 2;
            const maxRadius = size / 2 - 20;
            const innerRadius = maxRadius * 0.3;
            
            // Compute segment data
            const segments = new Array(ANGLE_SEGMENTS).fill(null).map(() => ({
                A: 0, B: 0, C: 0, D: 0, true: 0, false: 0
            }));
            
            for (let i = 0; i < ROWS; i++) {
                if (filteredMask[i]) {
                    const segmentIndex = Math.floor(data.angle[i] / 360 * ANGLE_SEGMENTS);
                    if (mode === 'category_4') {
                        const cat = ['A', 'B', 'C', 'D'][data.category_4[i]];
                        segments[segmentIndex][cat]++;
                    } else {
                        const cat = data.category_2[i] ? 'true' : 'false';
                        segments[segmentIndex][cat]++;
                    }
                }
            }
            
            // Find max for scaling
            let maxCount = 0;
            segments.forEach(seg => {
                const total = mode === 'category_4' ? 
                    seg.A + seg.B + seg.C + seg.D : 
                    seg.true + seg.false;
                maxCount = Math.max(maxCount, total);
            });
            
            // Draw segments
            const segmentAngle = 2 * Math.PI / ANGLE_SEGMENTS;
            
            segments.forEach((seg, i) => {
                const startAngle = i * segmentAngle - Math.PI / 2;
                const endAngle = (i + 1) * segmentAngle - Math.PI / 2;
                
                if (mode === 'category_4') {
                    const total = seg.A + seg.B + seg.C + seg.D;
                    if (total > 0) {
                        const barHeight = (total / maxCount) * (maxRadius - innerRadius);
                        const outerRadius = innerRadius + barHeight;
                        
                        let currentRadius = innerRadius;
                        ['A', 'B', 'C', 'D'].forEach(cat => {
                            if (seg[cat] > 0) {
                                const catHeight = (seg[cat] / total) * barHeight;
                                const nextRadius = currentRadius + catHeight;
                                
                                ctx.fillStyle = colors[cat];
                                ctx.beginPath();
                                ctx.arc(center, center, currentRadius, startAngle, endAngle);
                                ctx.arc(center, center, nextRadius, endAngle, startAngle, true);
                                ctx.closePath();
                                ctx.fill();
                                
                                currentRadius = nextRadius;
                            }
                        });
                    }
                } else {
                    const total = seg.true + seg.false;
                    if (total > 0) {
                        const barHeight = (maxRadius - innerRadius) * 0.7; // Fixed height
                        const outerRadius = innerRadius + barHeight;
                        
                        let currentRadius = innerRadius;
                        ['false', 'true'].forEach(cat => {
                            if (seg[cat] > 0) {
                                const catHeight = (seg[cat] / total) * barHeight;
                                const nextRadius = currentRadius + catHeight;
                                
                                ctx.fillStyle = colors[cat];
                                ctx.beginPath();
                                ctx.arc(center, center, currentRadius, startAngle, endAngle);
                                ctx.arc(center, center, nextRadius, endAngle, startAngle, true);
                                ctx.closePath();
                                ctx.fill();
                                
                                currentRadius = nextRadius;
                            }
                        });
                    }
                }
            });
            
            // Draw selection
            if (chart.selection) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                
                if (Array.isArray(chart.selection) && chart.selection.length === 4) {
                    // Wrap-around selection
                    const [s1, e1, s2, e2] = chart.selection;
                    ctx.beginPath();
                    ctx.arc(center, center, innerRadius, s1 * Math.PI / 180 - Math.PI / 2, e1 * Math.PI / 180 - Math.PI / 2);
                    ctx.arc(center, center, maxRadius, e1 * Math.PI / 180 - Math.PI / 2, s1 * Math.PI / 180 - Math.PI / 2, true);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(center, center, innerRadius, s2 * Math.PI / 180 - Math.PI / 2, e2 * Math.PI / 180 - Math.PI / 2);
                    ctx.arc(center, center, maxRadius, e2 * Math.PI / 180 - Math.PI / 2, s2 * Math.PI / 180 - Math.PI / 2, true);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else {
                    const [startDeg, endDeg] = chart.selection;
                    ctx.beginPath();
                    ctx.arc(center, center, innerRadius, startDeg * Math.PI / 180 - Math.PI / 2, endDeg * Math.PI / 180 - Math.PI / 2);
                    ctx.arc(center, center, maxRadius, endDeg * Math.PI / 180 - Math.PI / 2, startDeg * Math.PI / 180 - Math.PI / 2, true);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
            }
            
            // Draw grid lines
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            for (let angle = 0; angle < 360; angle += 45) {
                const rad = angle * Math.PI / 180 - Math.PI / 2;
                ctx.beginPath();
                ctx.moveTo(center, center);
                ctx.lineTo(center + Math.cos(rad) * maxRadius, center + Math.sin(rad) * maxRadius);
                ctx.stroke();
            }
            
            // Draw angle labels
            ctx.fillStyle = '#999';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            for (let angle = 0; angle < 360; angle += 45) {
                const rad = angle * Math.PI / 180 - Math.PI / 2;
                const x = center + Math.cos(rad) * (maxRadius + 12);
                const y = center + Math.sin(rad) * (maxRadius + 12);
                ctx.fillText(angle + '°', x, y);
            }
        }
        
        // Time chart implementation
        function initTimeChart(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = (rect.width - 20) * dpr;
            canvas.height = (rect.height - 40) * dpr;
            canvas.style.width = (rect.width - 20) + 'px';
            canvas.style.height = (rect.height - 40) + 'px';
            ctx.scale(dpr, dpr);
            
            const width = rect.width - 20;
            const height = rect.height - 40;
            const margin = { top: 20, right: 20, bottom: 30, left: 40 };
            
            charts[canvasId] = {
                ctx,
                width,
                height,
                margin,
                draw: () => drawTimeChart(canvasId),
                selection: null,
                isDragging: false
            };
            
            // Mouse events similar to histogram
            let startX = null;
            
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                startX = e.clientX - rect.left;
                charts[canvasId].isDragging = true;
                charts[canvasId].selection = [startX, startX];
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                
                if (charts[canvasId].isDragging && startX !== null) {
                    charts[canvasId].selection = [Math.min(startX, x), Math.max(startX, x)];
                    drawTimeChart(canvasId);
                }
                
                // Tooltip
                const chart = charts[canvasId];
                const chartX = x - chart.margin.left;
                const chartWidth = chart.width - chart.margin.left - chart.margin.right;
                
                if (chartX >= 0 && chartX <= chartWidth) {
                    const timeInSeconds = (chartX / chartWidth) * 86400;
                    const hours = Math.floor(timeInSeconds / 3600);
                    const minutes = Math.floor((timeInSeconds % 3600) / 60);
                    showTooltip(e, `Time: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`);
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                if (charts[canvasId].isDragging && charts[canvasId].selection) {
                    const chart = charts[canvasId];
                    const chartWidth = chart.width - chart.margin.left - chart.margin.right;
                    const [x1, x2] = chart.selection;
                    
                    const start = ((x1 - chart.margin.left) / chartWidth) * 86400;
                    const end = ((x2 - chart.margin.left) / chartWidth) * 86400;
                    
                    filters.time = [Math.max(0, start), Math.min(86400, end)];
                    applyFilters();
                }
                
                charts[canvasId].isDragging = false;
                startX = null;
            });
            
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                
                if (x < margin.left || x > width - margin.right) {
                    filters.time = null;
                    charts[canvasId].selection = null;
                    applyFilters();
                }
            });
            
            canvas.addEventListener('mouseleave', () => {
                hideTooltip();
            });
        }
        
        // Draw time chart
        function drawTimeChart(canvasId) {
            const chart = charts[canvasId];
            const { ctx, width, height, margin } = chart;
            
            ctx.clearRect(0, 0, width, height);
            
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            // Compute histogram
            const bins = new Array(TIME_BINS).fill(0);
            const filteredBins = new Array(TIME_BINS).fill(0);
            const binSize = 86400 / TIME_BINS;
            
            for (let i = 0; i < ROWS; i++) {
                const binIndex = Math.floor(data.time[i] / binSize);
                if (binIndex >= 0 && binIndex < TIME_BINS) {
                    bins[binIndex]++;
                    if (filteredMask[i]) {
                        filteredBins[binIndex]++;
                    }
                }
            }
            
            const maxCount = Math.max(...bins);
            const barWidth = chartWidth / TIME_BINS;
            
            // Draw bars
            ctx.fillStyle = '#333';
            for (let i = 0; i < TIME_BINS; i++) {
                const barHeight = (bins[i] / maxCount) * chartHeight;
                ctx.fillRect(
                    margin.left + i * barWidth,
                    margin.top + chartHeight - barHeight,
                    barWidth - 1,
                    barHeight
                );
            }
            
            ctx.fillStyle = '#2563eb';
            for (let i = 0; i < TIME_BINS; i++) {
                const barHeight = (filteredBins[i] / maxCount) * chartHeight;
                ctx.fillRect(
                    margin.left + i * barWidth,
                    margin.top + chartHeight - barHeight,
                    barWidth - 1,
                    barHeight
                );
            }
            
            // Draw selection
            if (chart.selection) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(
                    chart.selection[0],
                    margin.top,
                    chart.selection[1] - chart.selection[0],
                    chartHeight
                );
            }
            
            // Draw axes
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top + chartHeight);
            ctx.lineTo(margin.left + chartWidth, margin.top + chartHeight);
            ctx.stroke();
            
            // Time labels
            ctx.fillStyle = '#999';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';
            
            for (let hour = 0; hour <= 24; hour += 3) {
                const x = margin.left + (hour / 24) * chartWidth;
                ctx.fillText(`${hour}:00`, x, height - 10);
            }
        }
        
        // Category chart implementation
        function initCategoryChart(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = (rect.width - 20) * dpr;
            canvas.height = (rect.height - 40) * dpr;
            canvas.style.width = (rect.width - 20) + 'px';
            canvas.style.height = (rect.height - 40) + 'px';
            ctx.scale(dpr, dpr);
            
            const width = rect.width - 20;
            const height = rect.height - 40;
            const margin = { top: 20, right: 20, bottom: 30, left: 40 };
            
            charts[canvasId] = {
                ctx,
                width,
                height,
                margin,
                draw: () => drawCategoryChart(canvasId)
            };
            
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const chart = charts[canvasId];
                const chartWidth = chart.width - chart.margin.left - chart.margin.right;
                const barWidth = chartWidth / 4 * 0.8;
                const gap = chartWidth / 4 * 0.2;
                
                const categories = ['A', 'B', 'C', 'D'];
                
                for (let i = 0; i < 4; i++) {
                    const barX = chart.margin.left + i * (barWidth + gap) + gap/2;
                    
                    if (x >= barX && x <= barX + barWidth) {
                        if (filters.category.has(categories[i])) {
                            filters.category.delete(categories[i]);
                        } else {
                            filters.category.add(categories[i]);
                        }
                        applyFilters();
                        break;
                    }
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const chart = charts[canvasId];
                const chartWidth = chart.width - chart.margin.left - chart.margin.right;
                const barWidth = chartWidth / 4 * 0.8;
                const gap = chartWidth / 4 * 0.2;
                
                const categories = ['A', 'B', 'C', 'D'];
                let found = false;
                
                for (let i = 0; i < 4; i++) {
                    const barX = chart.margin.left + i * (barWidth + gap) + gap/2;
                    
                    if (x >= barX && x <= barX + barWidth) {
                        showTooltip(e, `Category ${categories[i]}: Click to toggle`);
                        found = true;
                        break;
                    }
                }
                
                if (!found) {
                    hideTooltip();
                }
            });
            
            canvas.addEventListener('mouseleave', () => {
                hideTooltip();
            });
        }
        
        // Draw category chart
        function drawCategoryChart(canvasId) {
            const chart = charts[canvasId];
            const { ctx, width, height, margin } = chart;
            
            ctx.clearRect(0, 0, width, height);
            
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            // Count categories
            const counts = { A: 0, B: 0, C: 0, D: 0 };
            const filteredCounts = { A: 0, B: 0, C: 0, D: 0 };
            
            for (let i = 0; i < ROWS; i++) {
                const cat = ['A', 'B', 'C', 'D'][data.category_4[i]];
                counts[cat]++;
                if (filteredMask[i]) {
                    filteredCounts[cat]++;
                }
            }
            
            const maxCount = Math.max(...Object.values(counts));
            const barWidth = chartWidth / 4 * 0.8;
            const gap = chartWidth / 4 * 0.2;
            
            // Draw bars
            const categories = ['A', 'B', 'C', 'D'];
            categories.forEach((cat, i) => {
                const x = margin.left + i * (barWidth + gap) + gap/2;
                
                // Background bar
                ctx.fillStyle = '#333';
                const bgHeight = (counts[cat] / maxCount) * chartHeight;
                ctx.fillRect(x, margin.top + chartHeight - bgHeight, barWidth, bgHeight);
                
                // Filtered bar
                ctx.fillStyle = filters.category.has(cat) ? colors[cat] : '#666';
                const fgHeight = (filteredCounts[cat] / maxCount) * chartHeight;
                ctx.fillRect(x, margin.top + chartHeight - fgHeight, barWidth, fgHeight);
                
                // Label
                ctx.fillStyle = '#999';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(cat, x + barWidth/2, height - 10);
                
                // Count
                ctx.fillText(filteredCounts[cat].toLocaleString(), x + barWidth/2, margin.top + chartHeight - fgHeight - 5);
            });
            
            // Draw axes
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top + chartHeight);
            ctx.lineTo(margin.left + chartWidth, margin.top + chartHeight);
            ctx.stroke();
        }
        
        // Tooltip functions
        function showTooltip(event, text) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = text;
            tooltip.style.display = 'block';
            tooltip.style.left = event.pageX + 10 + 'px';
            tooltip.style.top = event.pageY - 30 + 'px';
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
        
        function getHistogramTooltip(canvasId, x, y) {
            const chart = charts[canvasId];
            const chartX = x - chart.margin.left;
            const chartWidth = chart.width - chart.margin.left - chart.margin.right;
            
            if (chartX < 0 || chartX > chartWidth) return '';
            
            const binIndex = Math.floor((chartX / chartWidth) * BINS);
            const binSize = (chart.range[1] - chart.range[0]) / BINS;
            const binStart = chart.range[0] + binIndex * binSize;
            const binEnd = binStart + binSize;
            
            return `${chart.label}: ${binStart.toFixed(1)} - ${binEnd.toFixed(1)}`;
        }
        
        // Apply filters
        function applyFilters() {
            filteredCount = 0;
            
            for (let i = 0; i < ROWS; i++) {
                let include = true;
                
                // Width filter
                if (filters.width && (data.width[i] < filters.width[0] || data.width[i] > filters.width[1])) {
                    include = false;
                }
                
                // Height filter
                if (include && filters.height && (data.height[i] < filters.height[0] || data.height[i] > filters.height[1])) {
                    include = false;
                }
                
                // Strength filter
                if (include && filters.strength && (data.strength[i] < filters.strength[0] || data.strength[i] > filters.strength[1])) {
                    include = false;
                }
                
                // Time filter
                if (include && filters.time && (data.time[i] < filters.time[0] || data.time[i] > filters.time[1])) {
                    include = false;
                }
                
                // Angle filter
                if (include && filters.angle) {
                    const angle = data.angle[i];
                    if (Array.isArray(filters.angle) && filters.angle.length === 4) {
                        // Wrap-around selection
                        const [s1, e1, s2, e2] = filters.angle;
                        include = (angle >= s1 && angle <= e1) || (angle >= s2 && angle <= e2);
                    } else {
                        const [start, end] = filters.angle;
                        include = angle >= start && angle <= end;
                    }
                }
                
                // Category filter
                if (include) {
                    const cat = ['A', 'B', 'C', 'D'][data.category_4[i]];
                    if (!filters.category.has(cat)) {
                        include = false;
                    }
                }
                
                filteredMask[i] = include ? 1 : 0;
                if (include) filteredCount++;
            }
            
            updateStats();
            updateAllCharts();
        }
        
        // Update statistics
        function updateStats() {
            document.getElementById('filteredCount').textContent = filteredCount.toLocaleString();
            document.getElementById('selectedPercent').textContent = Math.round(filteredCount / ROWS * 100) + '%';
        }
        
        // Update all charts
        function updateAllCharts() {
            Object.values(charts).forEach(chart => {
                if (chart.draw) {
                    chart.draw();
                }
            });
        }
        
        // Update angle chart when mode changes
        function updateAngleChart() {
            drawRadialChart('angleChart');
        }
        
        // Reset all filters
        function resetAllFilters() {
            filters = {
                width: null,
                height: null,
                angle: null,
                time: null,
                strength: null,
                category: new Set(['A', 'B', 'C', 'D'])
            };
            
            Object.values(charts).forEach(chart => {
                chart.selection = null;
            });
            
            applyFilters();
        }
        
        // Export CSV
        function exportCSV() {
            const headers = 'good_time,width,height,angle,strength,category_4,category_2\n';
            let csvContent = headers;
            let count = 0;
            
            for (let i = 0; i < ROWS && count < 100000; i++) {
                if (filteredMask[i]) {
                    const h = Math.floor(data.time[i] / 3600);
                    const m = Math.floor((data.time[i] % 3600) / 60);
                    const s = Math.floor(data.time[i] % 60);
                    const ms = Math.floor((data.time[i] % 1) * 1000);
                    const timeStr = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
                    
                    const cat = ['A', 'B', 'C', 'D'][data.category_4[i]];
                    const bool = data.category_2[i] ? 'true' : 'false';
                    
                    csvContent += `${timeStr},${data.width[i].toFixed(2)},${data.height[i].toFixed(2)},${data.angle[i].toFixed(2)},${data.strength[i].toFixed(2)},${cat},${bool}\n`;
                    count++;
                }
            }
            
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `filtered_data_${filteredCount}_rows.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Initialize on load
        window.onload = function() {
            generateData();
        };
    </script>
</body>
</html>